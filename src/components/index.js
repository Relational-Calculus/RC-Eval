import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,"¬":6, NOT:8, "∧":20, AND:22, "∨":24, OR:26, "⇒":28, IMPLIES:30, "∃":34, EXISTS:36, "∀":40, FORALL:42};
const parser = LRParser.deserialize({
  version: 14,
  states: "+^QVQPOOOzOQO'#CaO!YOSO'#CaO!hQWO'#C^O!kQWO'#C^O#UQPO'#C|OOQO'#Cv'#CvO#fQPO'#C|O$UQPO'#C|O$`QPO'#C^O$}QPO'#ClQOQPOOOOOO'#Ct'#CtO%SOQO,58{OOQO,58{,58{OOOO'#Cu'#CuO%bOSO,58{O%pQPO,58xO&OQPO,59^O&ZQWO,58xO&^QWO,58xO#iQPO,59hO&cQPO,59hO&jQPO'#ClOOQO-E6t-E6tO&{QPO'#CrO'QQPO,59hO'[QPO,59hOVQPO,59hOOQO'#Ce'#CeO'gQWO,58xO'jQWO,58xO'oQPO,58xO$}QPO,59WO'}QPO'#CoO(VQPO,59WOOOO-E6r-E6rOOQO1G.g1G.gOOOO-E6s-E6sOOQO1G.d1G.dO([QPO'#CsO(dQPO1G.xO(iQPO1G.dO(wQPO1G/SOOQO1G/S1G/SOVQPO1G/SO)OQPO,59^P)TQPO'#ClOVQPO1G/SO&vQPO'#CrO)cQPO1G.dO&OQPO1G.xO)qQWO1G.dO)vQPO1G.rO){QPO'#CwO*QQPO,59ZOOQO1G.r1G.rO*YQPO'#CxO*eQPO,59_OOQO7+$d7+$dO*mQPO7+$OOOQO7+$n7+$nOVQPO7+$nO*rQPO7+$nOOQO7+$O7+$OO*wQPO7+$dO*|QPO7+$OOOQO7+$^7+$^OOQO,59c,59cOOQO-E6u-E6uOOQO,59d,59dOOQO-E6v-E6vOOQO<<Gj<<GjO+[QPO<<HYOOQO<<HY<<HYOOQO<<HO<<HOO+aQPO<<GjOOQOAN=tAN=tOOQOAN=UAN=U",
  stateData: "+f~OoOS~ORXOSXOVTOaYObYOdYOeYOqROrPOuQOwSO~OU[Or^Os[Ot^O~OU_Ot^Ou^Ov_O~OVbOxaO~ORgOSgOaYObYOdYOeYO~OqcOrPOuQOwdO~P!pOVkOqiO~P!pOYmOZmO[mO]mO^mO_mO~OmpXWpX~P#pOVpOaqObqOdqOeqOqnOrPOuQOwoO~OqrO~OU[OruOs[OtuO~OU_OtuOuuOv_O~OqwOrPOuQOwwO~OqxOrPOuQO~OVbOxzO~OW|O~P#pOaqObqOdqOeqOq!OO~OVbO~OmpaWpa~P#pOR!ROS!ROqiO~OV!TOx!SO~Oq!UOrPOuQOw!UO~Oy!WOzcX~Oz!YO~Oy!ZOWgX~OW!]O~Oq!^OrPOuQOw!^O~OW!_O~P#pOV!TO~OaqObqOdqOeqO~Oq!bOrPOuQOw!bO~Ox!dO~Oz!eO~Oq!fO~Oy!WOzca~Oq!hOrPOuQO~Oy!ZOWga~OW!jO~OW!lO~OW!mO~Oq!nOrPOuQOw!nO~OW!oO~OW!pO~O",
  goto: "$zqPPrPPyPPP!nPPPPPP!zPP#UPP#[#m#s#y$P$_$ePPP$kZWOl}!Q!`YSOl}!Q!`QdTQoXQwaSxb!TQ!UpQ!^zQ!b!SQ!h!ZR!n!dQlWQ}fQ!QjR!`{aUOTVel}!Q!`QsYR!VqYWOl}!Q!`QfTQjVT{ekQybR!c!TQ]PRt]Q`QRv`YVOl}!Q!`QeTThVeQ!XrR!g!XQ![xR!i![QZOQ|lQ!_!QQ!a}R!k!`",
  nodeNames: "⚠ Program EqualsExpression ¬ NOT String Escape ( ) InfixExpression ∧ AND ∨ OR ⇒ IMPLIES PrefixExpression ∃ EXISTS varList ∀ FORALL TableExpression varList",
  maxTerm: 42,
  skippedNodes: [0],
  repeatNodeCount: 5,
  tokenData: "2]~R{OX#xXY&XYZ'uZ]#x]^&X^p#xpq&Xqr#xrs(Ysw#xwx(vxy)dyz*]z|#x|}+U}!O#x!O!P+}!P!Q#x!Q![,v![!_#x!_!`-O!`!c#x!c!}0P!}#O#x#O#P2W#P#R#x#R#S0P#S#T#x#T#o0P#o$r#x$r$s0P$s%%Y#x%%Y%%Z0P%%Z%&Y#x%&Y%&Z0P%&Z%&]#x%&]%&^0P%&^%'R#x%'R%'S0P%'S%'T0P%'T;'S#x;'S;=`&R<%lO#xU$PYsQvSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xS$tVvSOY$oZw$ox!Q$o![#O$o#P;'S$o;'S;=`%Z<%lO$oS%^P;=`<%l$oQ%fVsQOY%aZr%as!Q%a![#O%a#P;'S%a;'S;=`%{<%lO%aQ&OP;=`<%l%aU&UP;=`<%l#x_&b`oXsQvSOX#xXY&XYZ'dZ]#x]^&X^p#xpq&Xqr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xX'iSoXXY'dYZ'd]^'dpq'd_'|StUoXXY'dYZ'd]^'dpq'dV(aVrRvSOY$oZw$ox!Q$o![#O$o#P;'S$o;'S;=`%Z<%lO$oV(}VuTsQOY%aZr%as!Q%a![#O%a#P;'S%a;'S;=`%{<%lO%a_)mYVXsQvSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV*fYWPsQvSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV+_YyPsQvSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV,WYzPsQvSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#x~,{Pw~!Q![,v_-ZnxWqPsQvSOY#xZr#xrs$osw#xwx%ax!Q#x!Q![/X![!_#x!_!`0P!`!c#x!c!}0P!}#O#x#P#R#x#R#S0P#S#T#x#T#o0P#o$r#x$r$s0P$s%%Y#x%%Y%%Z0P%%Z%&Y#x%&Y%&Z0P%&Z%&]#x%&]%&^0P%&^%'R#x%'R%'S0P%'S%'T0P%'T;'S#x;'S;=`&R<%lO#xP/^ZqP!Q![/X!_!`/X!c!}/X#R#S/X#T#o/X$r$s/X%%Y%%Z/X%&Y%&Z/X%&]%&^/X%'R%'S/X%'S%'T/XV0YnqPsQvSOY#xZr#xrs$osw#xwx%ax!Q#x!Q![/X![!_#x!_!`0P!`!c#x!c!}0P!}#O#x#P#R#x#R#S0P#S#T#x#T#o0P#o$r#x$r$s0P$s%%Y#x%%Y%%Z0P%%Z%&Y#x%&Y%&Z0P%&Z%&]#x%&]%&^0P%&^%'R#x%'R%'S0P%'S%'T0P%'T;'S#x;'S;=`&R<%lO#x~2]OU~",
  tokenizers: [0, 1, 2, 3],
  topRules: {"Program":[0,1]},
  specialized: [{term: 33, get: (value) => spec_identifier[value] || -1}],
  tokenPrec: 0
});

const RCLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false })
            }),
            styleTags({
                // identifier: t.string,
                "AND ∧ OR ∨ IMPLIES ⇒ EXISTS ∃ FORALL ∀ NOT ¬": tags.operatorKeyword,
                String: tags.string,
                "( )": tags.paren
            })
        ]
    })
});
function RC() {
    return new LanguageSupport(RCLanguage);
}

export { RC, RCLanguage };
