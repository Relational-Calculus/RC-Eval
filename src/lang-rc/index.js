import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_word = {__proto__:null,CNT:24, AVG:26, MAX:28, MIN:30, SUM:32, "∧":38, AND:40, "∨":42, OR:44, "⇒":46, IMPLIES:48, "∃":52, EXISTS:54, "∀":58, FORALL:60, "¬":62, NOT:64, LET:66, IN:68};
const parser = LRParser.deserialize({
  version: 14,
  states: ")`QVQPOOO}QPO'#C_O!YOQO'#C`O!hOSO'#C`O!vQPO'#C^O#OQPO'#C^O#TQPO'#CcOOQO'#DW'#DWOVQPO'#DWQ#YQPOOOVQPO'#DWO#nQPO'#CuOOQO'#Cu'#CuO#sQPO'#DWOOOO'#DP'#DPO$kOQO,58zOOQO,58z,58zOOOO'#DQ'#DQO$yOSO,58zO%XQPO,58xO%gQPO,59RO%xQPO,58}O&TQPO,59rOVQPO,59rOOQO'#Cn'#CnO&bQPO,59rOOQO'#C_'#C_O&iQPO'#CmO'gQPO,59aO'lQWO,59rOOOO-E6}-E6}OOQO1G.f1G.fOOOO-E7O-E7OOOQO1G.d1G.dO#nQPO1G.mO'sQPO'#CfO'{QPO1G.iOOQO1G/^1G/^O#nQPO'#DSO(QQPO,59XOOQO1G.{1G.{O)OQWO,59rOVQPO1G/^O)VQPO7+$XO%xQPO'#DRO*QQPO,59QOOQO7+$T7+$TOOQO,59n,59nOOQO-E7Q-E7QO*YQPO7+$xO#nQPO<<GsOOQO,59m,59mOOQO-E7P-E7POVQPO<<HdOOQOAN=_AN=_O*aQPOAN>OO*nQWOAN>OO#sQPO'#DWO#sQPO,59rO#sQPO<<HdO*uQPO7+$xOVQPO1G/^O*|QWO,59rO#sQPO'#DW",
  stateData: "+T~OyOS~OXYOjZOkZOmZOnZOo[Op[Oq]O{PO|QO!PRO!RTO~OXWX!SRX!URX~OT^O|`O}^O!O`O~OTaO!O`O!P`O!QaO~O!ScO!UdO~O!ScO~OXeO~OchOdhOehOfhOghOhhO~O{jO~OXYOjZOkZOmZOnZOo[Op[Oq!aO{PO|QO!PRO!RTO~OT^O|oO}^O!OoO~OTaO!OoO!PoO!QaO~O{jO|QO!PRO!RqO~O[rO]rO^rO_rO`rO~O{jO|QO!PRO~OwzaUzarza~P#YOUuO~P#YO!TvOlaXXaXjaXkaXmaXnaXoaXpaXqaX{aX|aX!PaX!RaX~OlxO~O!WzO~P#YO!T|OUYX~OU!OO~O!TvOlaaXaajaakaamaanaaoaapaaqaa{aa|aa!Paa!Raa~O!Wza~P#YO!V!SOXZqjZqkZqmZqnZqoZqpZqqZq{Zq|Zq!PZq!RZq~O!T|OUYa~Or!VO~P#YOwz!RUz!Rrz!R~P#YO!Wz!R~P#YOr!]O~P#YO!W!_O~P#YO",
  goto: "%y{PP|![!}PP|#fP#t#wPPPPP$X$_PPPPPP#wPPPPPPPPP$m$s$y%PPPP%ViVOWY]gz!V!Z![!]!_!ahSOWY]gz!V!Z![!]!_!aSkZ!SQqcQseQ{rQ!PvR!T|hTOWY]gz!V!Z![!]!_!aQqcQseR!T|iUOWY]gz!V!Z![!]!_!aRte^WOWYgz!V!_Z!Z]!Z![!]!aQlZR!W!S[gXfi!R!X!^X![my!Y!`Q_QRn_QbRRpbQ}sR!U}QwkR!QwQXOQfWQiYQm]Sug![Qy!ZQ!RzQ!X!VQ!Y!]Q!^!_R!`!a",
  nodeNames: "⚠ Program EqualsExpression Identifier String Escape ) TableExpression TableName ( varList AggregateExpression CNT AVG MAX MIN SUM varList InfixExpression ∧ AND ∨ OR ⇒ IMPLIES PrefixExpression ∃ EXISTS . ∀ FORALL ¬ NOT LET IN",
  maxTerm: 54,
  skippedNodes: [0],
  repeatNodeCount: 4,
  tokenData: "4m~R!QOX$XXY&hYZ(UZ]$X]^&h^p$Xpq&hqr$Xrs(isw$Xwx)Vxy)syz*lz|$X|}+e}!O$X!O!P,^!P!Q$X!Q![-V![!]$X!]!^-_!^!_.W!_!`0O!`!a0y!a!c$X!c!}1r!}#O$X#O#P4h#P#R$X#R#S1r#S#T$X#T#o1r#o$r$X$r$s1r$s%%Y$X%%Y%%Z1r%%Z%&Y$X%&Y%&Z1r%&Z%&]$X%&]%&^1r%&^%'R$X%'R%'S1r%'S%'T1r%'T%'t$X%'t%'u0y%'u;'S$X;'S;=`&b<%lO$XU$`Y}Q!QSOY$XZr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$XS%TV!QSOY%OZw%Ox!Q%O![#O%O#P;'S%O;'S;=`%j<%lO%OS%mP;=`<%l%OQ%uV}QOY%pZr%ps!Q%p![#O%p#P;'S%p;'S;=`&[<%lO%pQ&_P;=`<%l%pU&eP;=`<%l$X_&q`yX}Q!QSOX$XXY&hYZ'sZ]$X]^&h^p$Xpq&hqr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$XX'xSyXXY'sYZ's]^'spq's_(]S!OUyXXY'sYZ's]^'spq'sV(pV|R!QSOY%OZw%Ox!Q%O![#O%O#P;'S%O;'S;=`%j<%lO%OV)^V!PT}QOY%pZr%ps!Q%p![#O%p#P;'S%p;'S;=`&[<%lO%pV)|YXP}Q!QSOY$XZr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$XV*uYUP}Q!QSOY$XZr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$XV+nY!TP}Q!QSOY$XZr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$XV,gYlP}Q!QSOY$XZr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$X~-[P!R~!Q![-VV-hY!VP}Q!QSOY$XZr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$XV.a[!SP}Q!QSOY$XZr$Xrs%Osw$Xwx%px}$X}!O/V!O!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$XV/`Y!UP}Q!QSOY$XZr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$X_0ZY!WW!SP}Q!QSOY$XZr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$XV1SY!SP}Q!QSOY$XZr$Xrs%Osw$Xwx%px!Q$X![#O$X#P;'S$X;'S;=`&b<%lO$X_1{l}Q!QS{XOY$XZr$Xrs%Osw$Xwx%px!Q$X!Q![3s![!c$X!c!}1r!}#O$X#P#R$X#R#S1r#S#T$X#T#o1r#o$r$X$r$s1r$s%%Y$X%%Y%%Z1r%%Z%&Y$X%&Y%&Z1r%&Z%&]$X%&]%&^1r%&^%'R$X%'R%'S1r%'S%'T1r%'T;'S$X;'S;=`&b<%lO$XX3xY{X!Q![3s!c!}3s#R#S3s#T#o3s$r$s3s%%Y%%Z3s%&Y%&Z3s%&]%&^3s%'R%'S3s%'S%'T3s~4mOT~",
  tokenizers: [0, 1, 2, 3],
  topRules: {"Program":[0,1]},
  specialized: [{term: 43, get: (value) => spec_word[value] || -1}],
  tokenPrec: 0
});

const RCLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false })
            }),
            styleTags({
                // identifier: t.string,
                "AND ∧ OR ∨ IMPLIES ⇒ EXISTS ∃ FORALL ∀ NOT ¬ CNT SUM MAX MIN AVG": tags.operatorKeyword,
                "LET IN": tags.modifier,
                TableName: tags.definitionKeyword,
                Identifier: tags.variableName,
                String: tags.string,
                "( )": tags.paren
            })
        ]
    })
});
function RC() {
    return new LanguageSupport(RCLanguage);
}

export { RC, RCLanguage };
