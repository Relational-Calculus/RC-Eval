import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_word = {__proto__:null,"∧":24, AND:26, "∨":28, OR:30, "⇒":32, IMPLIES:34, "∃":38, EXISTS:40, "∀":46, FORALL:48, "¬":50, NOT:52};
const parser = LRParser.deserialize({
  version: 14,
  states: "&lQVQPOOOzQPO'#C_O!SOQO'#C`O!bOSO'#C`O!pQPO'#C^O!uQPO'#CcOOQO'#DO'#DOQ!zQPOOOVQPO'#DOOVQPO'#DOO#`QPO'#CnOOQO'#Cn'#CnOOOO'#Cw'#CwO#eOQO,58zOOQO,58z,58zOOOO'#Cx'#CxO#sOSO,58zO$RQPO,58xO$aQPO,58}OVQPO,59jOOQO'#Cg'#CgO$lQPO,59jO$vQPO,59jOOQO'#C_'#C_O$}QPO'#CqO%VQPO,59YOOOO-E6u-E6uOOQO1G.f1G.fOOOO-E6v-E6vOOQO1G.d1G.dO%[QPO'#CfO%dQPO1G.iOOQO1G/U1G/UO#`QPO'#CzO%iQPO,59]OOQO1G.t1G.tO$aQPO'#CyO%qQPO,59QOOQO7+$T7+$TOOQO,59f,59fOOQO-E6x-E6xOOQO,59e,59eOOQO-E6w-E6w",
  stateData: "%y~OqOS~OXXOcYOdYOgYOhYOiZOjZOsPOtQOwROySO~OXWXzRX~OT[Ot^Ou[Ov^O~OT_Ov^Ow^Ox_O~OzaO~OXbO~O[dO]dO^dO_dO`dOadO~OsgO~OT[OtkOu[OvkO~OT_OvkOwkOx_O~OsgOtQOwROymO~OsgOtQOwRO~OoraUra~P!zOUpO~P!zO{qOfeX~OfsO~O{tOUYX~OUvO~O{qOfea~O{tOUYa~O",
  goto: "#}sPPtz!aPPt!pP!v!yPPPPPP#OPP#UPPPPP#X#_#e#kPPP#qXUOWXcWSOWXcQhYQmaQnbQwqRytWSOWXcQmaQnbRytXTOWXcRobVcVefXWOWXcRiYQ]QRj]Q`RRl`QunRzuQrhRxrQVOQeWQfXRpc",
  nodeNames: "⚠ Program EqualsExpression Identifier String Escape ) TableExpression TableName ( varList InfixExpression ∧ AND ∨ OR ⇒ IMPLIES PrefixExpression ∃ EXISTS varList . ∀ FORALL ¬ NOT",
  maxTerm: 43,
  skippedNodes: [0],
  repeatNodeCount: 4,
  tokenData: "0x~R}OX$OXY&_YZ'{Z]$O]^&_^p$Opq&_qr$Ors(`sw$Owx(|xy)jyz*cz|$O|}+[}!O$O!O!P,T!P!Q$O!Q![,|![!_$O!_!`-U!`!c$O!c!}-}!}#O$O#O#P0s#P#R$O#R#S-}#S#T$O#T#o-}#o$r$O$r$s-}$s%%Y$O%%Y%%Z-}%%Z%&Y$O%&Y%&Z-}%&Z%&]$O%&]%&^-}%&^%'R$O%'R%'S-}%'S%'T-}%'T%'t$O%'t%'u-U%'u;'S$O;'S;=`&X<%lO$OU$VYuQxSOY$OZr$Ors$usw$Owx%gx!Q$O![#O$O#P;'S$O;'S;=`&X<%lO$OS$zVxSOY$uZw$ux!Q$u![#O$u#P;'S$u;'S;=`%a<%lO$uS%dP;=`<%l$uQ%lVuQOY%gZr%gs!Q%g![#O%g#P;'S%g;'S;=`&R<%lO%gQ&UP;=`<%l%gU&[P;=`<%l$OV&h`qPuQxSOX$OXY&_YZ'jZ]$O]^&_^p$Opq&_qr$Ors$usw$Owx%gx!Q$O![#O$O#P;'S$O;'S;=`&X<%lO$OP'oSqPXY'jYZ'j]^'jpq'jV(SSvUqPXY'jYZ'j]^'jpq'jV(gVtRxSOY$uZw$ux!Q$u![#O$u#P;'S$u;'S;=`%a<%lO$uV)TVwTuQOY%gZr%gs!Q%g![#O%g#P;'S%g;'S;=`&R<%lO%gV)sYXPuQxSOY$OZr$Ors$usw$Owx%gx!Q$O![#O$O#P;'S$O;'S;=`&X<%lO$OV*lYUPuQxSOY$OZr$Ors$usw$Owx%gx!Q$O![#O$O#P;'S$O;'S;=`&X<%lO$OV+eY{PuQxSOY$OZr$Ors$usw$Owx%gx!Q$O![#O$O#P;'S$O;'S;=`&X<%lO$OV,^YfPuQxSOY$OZr$Ors$usw$Owx%gx!Q$O![#O$O#P;'S$O;'S;=`&X<%lO$O~-RPy~!Q![,|V-_YzPuQxSOY$OZr$Ors$usw$Owx%gx!Q$O![#O$O#P;'S$O;'S;=`&X<%lO$OV.WluQxSsPOY$OZr$Ors$usw$Owx%gx!Q$O!Q![0O![!c$O!c!}-}!}#O$O#P#R$O#R#S-}#S#T$O#T#o-}#o$r$O$r$s-}$s%%Y$O%%Y%%Z-}%%Z%&Y$O%&Y%&Z-}%&Z%&]$O%&]%&^-}%&^%'R$O%'R%'S-}%'S%'T-}%'T;'S$O;'S;=`&X<%lO$OP0TYsP!Q![0O!c!}0O#R#S0O#T#o0O$r$s0O%%Y%%Z0O%&Y%&Z0O%&]%&^0O%'R%'S0O%'S%'T0O~0xOT~",
  tokenizers: [0, 1, 2],
  topRules: {"Program":[0,1]},
  specialized: [{term: 35, get: (value) => spec_word[value] || -1}],
  tokenPrec: 0
});

const RCLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false })
            }),
            styleTags({
                // identifier: t.string,
                "AND ∧ OR ∨ IMPLIES ⇒ EXISTS ∃ FORALL ∀ NOT ¬": tags.operatorKeyword,
                TableName: tags.definitionKeyword,
                Identifier: tags.variableName,
                String: tags.string,
                "( )": tags.paren
            })
        ]
    })
});
function RC() {
    return new LanguageSupport(RCLanguage);
}

export { RC, RCLanguage };
