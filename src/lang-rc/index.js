import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_word = {__proto__:null,CNT:24, AVG:26, MAX:28, MIN:30, SUM:32, "∧":38, AND:40, "∨":42, OR:44, "⇒":46, IMPLIES:48, "∃":52, EXISTS:54, "∀":58, FORALL:60, "¬":62, NOT:64, LET:66, IN:68};
const parser = LRParser.deserialize({
  version: 14,
  states: ")`QVQPOOO}QPO'#C_O!YOQO'#C`O!hOSO'#C`O!vQPO'#C^O#OQPO'#C^O#TQPO'#CcOOQO'#DW'#DWOVQPO'#DWQ#YQPOOOVQPO'#DWO#nQPO'#CuOOQO'#Cu'#CuO#sQPO'#DWOOOO'#DP'#DPO$kOQO,58zOOQO,58z,58zOOOO'#DQ'#DQO$yOSO,58zO%XQPO,58xO%gQPO,59RO%xQPO,58}O&TQPO,59rOVQPO,59rOOQO'#Cn'#CnO&bQPO,59rOOQO'#C_'#C_O&iQPO'#CmO'gQPO,59aO'lQWO,59rOOOO-E6}-E6}OOQO1G.f1G.fOOOO-E7O-E7OOOQO1G.d1G.dO#nQPO1G.mO'sQPO'#CfO'{QPO1G.iOOQO1G/^1G/^O#nQPO'#DSO(QQPO,59XOOQO1G.{1G.{O)OQWO,59rOVQPO1G/^O)VQPO7+$XO%xQPO'#DRO*QQPO,59QOOQO7+$T7+$TOOQO,59n,59nOOQO-E7Q-E7QO*YQPO7+$xO#nQPO<<GsOOQO,59m,59mOOQO-E7P-E7POVQPO<<HdOOQOAN=_AN=_O*aQPOAN>OO*nQWOAN>OO#sQPO'#DWO#sQPO,59rO#sQPO<<HdO*uQPO7+$xOVQPO1G/^O*|QWO,59rO#sQPO'#DW",
  stateData: "+T~OyOS~OXYOjZOkZOmZOnZOo[Op[Oq]O{PO|QO!PRO!RTO~OXWX!SRX!URX~OT^O|`O}^O!O`O~OTaO!O`O!P`O!QaO~O!ScO!UdO~O!ScO~OXeO~OchOdhOehOfhOghOhhO~O{jO~OXYOjZOkZOmZOnZOo[Op[Oq!aO{PO|QO!PRO!RTO~OT^O|oO}^O!OoO~OTaO!OoO!PoO!QaO~O{jO|QO!PRO!RqO~O[rO]rO^rO_rO`rO~O{jO|QO!PRO~OwzaUzarza~P#YOUuO~P#YO!TvOlaXXaXjaXkaXmaXnaXoaXpaXqaX{aX|aX!PaX!RaX~OlxO~O!WzO~P#YO!T|OUYX~OU!OO~O!TvOlaaXaajaakaamaanaaoaapaaqaa{aa|aa!Paa!Raa~O!Wza~P#YO!V!SOXZqjZqkZqmZqnZqoZqpZqqZq{Zq|Zq!PZq!RZq~O!T|OUYa~Or!VO~P#YOwz!RUz!Rrz!R~P#YO!Wz!R~P#YOr!]O~P#YO!W!_O~P#YO",
  goto: "%y{PP|![!}PP|#fP#t#wPPPPP$X$_PPPPPP#wPPPPPPPPP$m$s$y%PPPP%ViVOWY]gz!V!Z![!]!_!ahSOWY]gz!V!Z![!]!_!aSkZ!SQqcQseQ{rQ!PvR!T|hTOWY]gz!V!Z![!]!_!aQqcQseR!T|iUOWY]gz!V!Z![!]!_!aRte^WOWYgz!V!_Z!Z]!Z![!]!aQlZR!W!S[gXfi!R!X!^X![my!Y!`Q_QRn_QbRRpbQ}sR!U}QwkR!QwQXOQfWQiYQm]Sug![Qy!ZQ!RzQ!X!VQ!Y!]Q!^!_R!`!a",
  nodeNames: "⚠ Program EqualsExpression Identifier String Escape ) TableExpression TableName ( varList AggregateExpression CNT AVG MAX MIN SUM varList InfixExpression ∧ AND ∨ OR ⇒ IMPLIES PrefixExpression ∃ EXISTS . ∀ FORALL ¬ NOT LET IN",
  maxTerm: 54,
  skippedNodes: [0],
  repeatNodeCount: 4,
  tokenData: "3m~R!QOX$XXY&_YZ'xZ]$X]^&_^p$Xpq&_qr$Xrs(]sw$Xwx(vxy)ayz*Vz|$X|}*{}!O$X!O!P+q!P!Q$X!Q![,g![!]$X!]!^-c!^!_.X!_!`/y!`!a0q!a!c$X!c!}1g!}#O$X#O#P3h#P#R$X#R#S1g#S#T$X#T#o1g#o$r$X$r$s1g$s%%Y$X%%Y%%Z1g%%Z%&Y$X%&Y%&Z1g%&Z%&]$X%&]%&^1g%&^%'R$X%'R%'S1g%'S%'T1g%'T%'t$X%'t%'u0q%'u;'S$X;'S;=`&X<%lO$XU$`X}Q!QSOY$XZr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$XS%QU!QSOY${Zw${x#O${#P;'S${;'S;=`%d<%lO${S%gP;=`<%l${Q%oU}QOY%jZr%js#O%j#P;'S%j;'S;=`&R<%lO%jQ&UP;=`<%l%jU&[P;=`<%l$X_&h_yX}Q!QSOX$XXY&_YZ'gZ]$X]^&_^p$Xpq&_qr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$XX'lSyXXY'gYZ'g]^'gpq'g_(PS!OUyXXY'gYZ'g]^'gpq'gV(dU|R!QSOY${Zw${x#O${#P;'S${;'S;=`%d<%lO${V(}U!PT}QOY%jZr%js#O%j#P;'S%j;'S;=`&R<%lO%jV)jXXP}Q!QSOY$XZr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$XV*`XUP}Q!QSOY$XZr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$XV+UX!TP}Q!QSOY$XZr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$XV+zXlP}Q!QSOY$XZr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$XV,pZ!RP}Q!QSOY$XZr$Xrs${sw$Xwx%jx!Q$X!Q![,g![#O$X#P;'S$X;'S;=`&X<%lO$XV-lX!VP}Q!QSOY$XZr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$XV.bZ!SP}Q!QSOY$XZr$Xrs${sw$Xwx%jx}$X}!O/T!O#O$X#P;'S$X;'S;=`&X<%lO$XV/^X!UP}Q!QSOY$XZr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$X_0UX!WW!SP}Q!QSOY$XZr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$XV0zX!SP}Q!QSOY$XZr$Xrs${sw$Xwx%jx#O$X#P;'S$X;'S;=`&X<%lO$X_1pl}Q!QS{XOY$XZr$Xrs${sw$Xwx%jx!Q$X!Q![1g![!c$X!c!}1g!}#O$X#P#R$X#R#S1g#S#T$X#T#o1g#o$r$X$r$s1g$s%%Y$X%%Y%%Z1g%%Z%&Y$X%&Y%&Z1g%&Z%&]$X%&]%&^1g%&^%'R$X%'R%'S1g%'S%'T1g%'T;'S$X;'S;=`&X<%lO$X~3mOT~",
  tokenizers: [0, 1, 2, 3],
  topRules: {"Program":[0,1]},
  specialized: [{term: 43, get: (value) => spec_word[value] || -1}],
  tokenPrec: 0
});

const RCLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false })
            }),
            styleTags({
                // identifier: t.string,
                "AND ∧ OR ∨ IMPLIES ⇒ EXISTS ∃ FORALL ∀ NOT ¬ CNT SUM MAX MIN AVG": tags.operatorKeyword,
                "LET IN": tags.modifier,
                TableName: tags.definitionKeyword,
                Identifier: tags.variableName,
                String: tags.string,
                "( )": tags.paren
            })
        ]
    })
});
function RC() {
    return new LanguageSupport(RCLanguage);
}

export { RC, RCLanguage };
