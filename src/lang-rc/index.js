import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_identifier = {__proto__:null,"∧":20, AND:22, "∨":24, OR:26, "⇒":28, IMPLIES:30, "∃":34, EXISTS:36, "∀":40, FORALL:42, "¬":44, NOT:46};
const parser = LRParser.deserialize({
  version: 14,
  states: "&`QVQPOOOzOQO'#C_O!YOSO'#C_O!hQPO'#C^O!kQPO'#C^OOQO'#C{'#C{Q!pQPOOOVQPO'#C{OVQPO'#C{O#UQPO'#ClOOQO'#Cl'#ClOOOO'#Ct'#CtO#ZOQO,58yOOQO,58y,58yOOOO'#Cu'#CuO#iOSO,58yO#wQPO,58xO$VQPO,58|OVQPO,59gOOQO'#Ce'#CeO$bQPO,59gO$lQPO,59gO$sQPO'#CoO${QPO,59WOOOO-E6r-E6rOOQO1G.e1G.eOOOO-E6s-E6sOOQO1G.d1G.dO%QQPO'#CdO%YQPO1G.hOOQO1G/R1G/RO%_QPO'#CwO%dQPO,59ZOOQO1G.r1G.rO%lQPO'#CvO%wQPO,59OOOQO7+$S7+$SOOQO,59c,59cOOQO-E6u-E6uOOQO,59b,59bOOQO-E6t-E6t",
  stateData: "&P~OnOS~OVWOaXObXOdXOeXOfYOgYOpROqPOtQOvSO~OSZOq]OrZOs]O~OS^Os]Ot]Ou^O~OVaOw`O~OYcOZcO[cO]cO^cO_cO~OpfO~OSZOqiOrZOsiO~OS^OsiOtiOu^O~OpkOqPOtQOvkO~OplOqPOtQO~OloaToa~P!pOTnO~P!pOxoOycX~OyqO~OxrOTWX~OTtO~OpuO~OxoOyca~OpwOqPOtQO~OxrOTWa~O",
  goto: "#_pPPqwPPqP!W!ZPPPPPP!`PP!fPPPP!i!o!u!{PPP#RXTOVWbWSOVWbQk`QlaRwrRmaVbUdeXVOVWbRgXQ[PRh[Q_QRj_QslRxsQpfRvpQUOQdVQeWRnb",
  nodeNames: "⚠ Program EqualsExpression String Escape ) TableExpression ( varList InfixExpression ∧ AND ∨ OR ⇒ IMPLIES PrefixExpression ∃ EXISTS varList ∀ FORALL ¬ NOT",
  maxTerm: 41,
  skippedNodes: [0],
  repeatNodeCount: 4,
  tokenData: "0r~R{OX#xXY&XYZ'uZ]#x]^&X^p#xpq&Xqr#xrs(Ysw#xwx(vxy)dyz*]z|#x|}+U}!O#x!O!P+}!P!Q#x!Q![,v![!_#x!_!`-O!`!c#x!c!}-w!}#O#x#O#P0m#P#R#x#R#S-w#S#T#x#T#o-w#o$r#x$r$s-w$s%%Y#x%%Y%%Z-w%%Z%&Y#x%&Y%&Z-w%&Z%&]#x%&]%&^-w%&^%'R#x%'R%'S-w%'S%'T-w%'T;'S#x;'S;=`&R<%lO#xU$PYrQuSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xS$tVuSOY$oZw$ox!Q$o![#O$o#P;'S$o;'S;=`%Z<%lO$oS%^P;=`<%l$oQ%fVrQOY%aZr%as!Q%a![#O%a#P;'S%a;'S;=`%{<%lO%aQ&OP;=`<%l%aU&UP;=`<%l#xV&b`nPrQuSOX#xXY&XYZ'dZ]#x]^&X^p#xpq&Xqr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xP'iSnPXY'dYZ'd]^'dpq'dV'|SsUnPXY'dYZ'd]^'dpq'dV(aVqRuSOY$oZw$ox!Q$o![#O$o#P;'S$o;'S;=`%Z<%lO$oV(}VtTrQOY%aZr%as!Q%a![#O%a#P;'S%a;'S;=`%{<%lO%aV)mYVPrQuSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV*fYTPrQuSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV+_YxPrQuSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV,WYyPrQuSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#x~,{Pv~!Q![,vV-XYwPrQuSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV.QlpPrQuSOY#xZr#xrs$osw#xwx%ax!Q#x!Q![/x![!c#x!c!}-w!}#O#x#P#R#x#R#S-w#S#T#x#T#o-w#o$r#x$r$s-w$s%%Y#x%%Y%%Z-w%%Z%&Y#x%&Y%&Z-w%&Z%&]#x%&]%&^-w%&^%'R#x%'R%'S-w%'S%'T-w%'T;'S#x;'S;=`&R<%lO#xP/}YpP!Q![/x!c!}/x#R#S/x#T#o/x$r$s/x%%Y%%Z/x%&Y%&Z/x%&]%&^/x%'R%'S/x%'S%'T/x~0rOS~",
  tokenizers: [0, 1, 2],
  topRules: {"Program":[0,1]},
  specialized: [{term: 32, get: (value) => spec_identifier[value] || -1}],
  tokenPrec: 0
});

const RCLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false })
            }),
            styleTags({
                // identifier: t.string,
                "AND ∧ OR ∨ IMPLIES ⇒ EXISTS ∃ FORALL ∀ NOT ¬": tags.operatorKeyword,
                Tablename: tags.variableName,
                String: tags.string,
                "( )": tags.paren
            })
        ]
    })
});
function RC() {
    return new LanguageSupport(RCLanguage);
}

export { RC, RCLanguage };
