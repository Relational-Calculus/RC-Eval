import { LRParser } from '@lezer/lr';
import { LRLanguage, indentNodeProp, delimitedIndent, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@lezer/highlight';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_word = {__proto__:null,"∧":24, AND:26, "∨":28, OR:30, "⇒":32, IMPLIES:34, "∃":38, EXISTS:40, "∀":46, FORALL:48, "¬":50, NOT:52};
const parser = LRParser.deserialize({
  version: 14,
  states: "&lQVQPOOOzQPO'#C_O!SOQO'#C`O!bOSO'#C`O!pQPO'#C^O!uQPO'#CcOOQO'#DO'#DOQ!zQPOOOVQPO'#DOOVQPO'#DOO#`QPO'#CnOOQO'#Cn'#CnOOOO'#Cw'#CwO#eOQO,58zOOQO,58z,58zOOOO'#Cx'#CxO#sOSO,58zO$RQPO,58xO$aQPO,58}OVQPO,59jOOQO'#Cg'#CgO$lQPO,59jO$vQPO,59jOOQO'#C_'#C_O$}QPO'#CqO%VQPO,59YOOOO-E6u-E6uOOQO1G.f1G.fOOOO-E6v-E6vOOQO1G.d1G.dO%[QPO'#CfO%dQPO1G.iOOQO1G/U1G/UO#`QPO'#CzO%iQPO,59]OOQO1G.t1G.tO$aQPO'#CyO%qQPO,59QOOQO7+$T7+$TOOQO,59f,59fOOQO-E6x-E6xOOQO,59e,59eOOQO-E6w-E6w",
  stateData: "%y~OqOS~OXXOcYOdYOgYOhYOiZOjZOsPOtQOwROySO~OXWXzRX~OT[Ot^Ou[Ov^O~OT_Ov^Ow^Ox_O~OzaO~OXbO~O[dO]dO^dO_dO`dOadO~OsgO~OT[OtkOu[OvkO~OT_OvkOwkOx_O~OsgOtQOwROymO~OsgOtQOwRO~OoraUra~P!zOUpO~P!zO{qOfeX~OfsO~O{tOUYX~OUvO~O{qOfea~O{tOUYa~O",
  goto: "#}sPPtz!aPPt!pP!v!yPPPPPP#OPP#UPPPPP#X#_#e#kPPP#qXUOWXcWSOWXcQhYQmaQnbQwqRytWSOWXcQmaQnbRytXTOWXcRobVcVefXWOWXcRiYQ]QRj]Q`RRl`QunRzuQrhRxrQVOQeWQfXRpc",
  nodeNames: "⚠ Program EqualsExpression Identifier String Escape ) TableExpression TableName ( varList InfixExpression ∧ AND ∨ OR ⇒ IMPLIES PrefixExpression ∃ EXISTS varList . ∀ FORALL ¬ NOT",
  maxTerm: 43,
  skippedNodes: [0],
  repeatNodeCount: 4,
  tokenData: "0r~R{OX#xXY&XYZ'uZ]#x]^&X^p#xpq&Xqr#xrs(Ysw#xwx(vxy)dyz*]z|#x|}+U}!O#x!O!P+}!P!Q#x!Q![,v![!_#x!_!`-O!`!c#x!c!}-w!}#O#x#O#P0m#P#R#x#R#S-w#S#T#x#T#o-w#o$r#x$r$s-w$s%%Y#x%%Y%%Z-w%%Z%&Y#x%&Y%&Z-w%&Z%&]#x%&]%&^-w%&^%'R#x%'R%'S-w%'S%'T-w%'T;'S#x;'S;=`&R<%lO#xU$PYuQxSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xS$tVxSOY$oZw$ox!Q$o![#O$o#P;'S$o;'S;=`%Z<%lO$oS%^P;=`<%l$oQ%fVuQOY%aZr%as!Q%a![#O%a#P;'S%a;'S;=`%{<%lO%aQ&OP;=`<%l%aU&UP;=`<%l#xV&b`qPuQxSOX#xXY&XYZ'dZ]#x]^&X^p#xpq&Xqr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xP'iSqPXY'dYZ'd]^'dpq'dV'|SvUqPXY'dYZ'd]^'dpq'dV(aVtRxSOY$oZw$ox!Q$o![#O$o#P;'S$o;'S;=`%Z<%lO$oV(}VwTuQOY%aZr%as!Q%a![#O%a#P;'S%a;'S;=`%{<%lO%aV)mYXPuQxSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV*fYUPuQxSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV+_Y{PuQxSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV,WYfPuQxSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#x~,{Py~!Q![,vV-XYzPuQxSOY#xZr#xrs$osw#xwx%ax!Q#x![#O#x#P;'S#x;'S;=`&R<%lO#xV.QluQxSsPOY#xZr#xrs$osw#xwx%ax!Q#x!Q![/x![!c#x!c!}-w!}#O#x#P#R#x#R#S-w#S#T#x#T#o-w#o$r#x$r$s-w$s%%Y#x%%Y%%Z-w%%Z%&Y#x%&Y%&Z-w%&Z%&]#x%&]%&^-w%&^%'R#x%'R%'S-w%'S%'T-w%'T;'S#x;'S;=`&R<%lO#xP/}YsP!Q![/x!c!}/x#R#S/x#T#o/x$r$s/x%%Y%%Z/x%&Y%&Z/x%&]%&^/x%'R%'S/x%'S%'T/x~0rOT~",
  tokenizers: [0, 1, 2],
  topRules: {"Program":[0,1]},
  specialized: [{term: 35, get: (value) => spec_word[value] || -1}],
  tokenPrec: 0
});

const RCLanguage = LRLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false })
            }),
            styleTags({
                // identifier: t.string,
                "AND ∧ OR ∨ IMPLIES ⇒ EXISTS ∃ FORALL ∀ NOT ¬": tags.operatorKeyword,
                TableName: tags.definitionKeyword,
                Identifier: tags.variableName,
                String: tags.string,
                "( )": tags.paren
            })
        ]
    })
});
function RC() {
    return new LanguageSupport(RCLanguage);
}

export { RC, RCLanguage };
