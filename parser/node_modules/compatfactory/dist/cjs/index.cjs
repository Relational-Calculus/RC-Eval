"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ensureNodeFactory = void 0;
function ensureNodeFactory(factoryLike) {
    if ("factory" in factoryLike && factoryLike.factory != null) {
        return normalizeNodeFactory(factoryLike.factory);
    }
    else if (!("updateSourceFileNode" in factoryLike)) {
        return normalizeNodeFactory(factoryLike);
    }
    return createNodeFactory(factoryLike);
}
exports.ensureNodeFactory = ensureNodeFactory;
function splitDecoratorsAndModifiers(modifierLikes) {
    var _a, _b;
    const decorators = ((_a = modifierLikes === null || modifierLikes === void 0 ? void 0 : modifierLikes.filter(modifier => "expression" in modifier)) !== null && _a !== void 0 ? _a : []);
    const modifiers = ((_b = modifierLikes === null || modifierLikes === void 0 ? void 0 : modifierLikes.filter(modifier => !("expression" in modifier))) !== null && _b !== void 0 ? _b : []);
    return [decorators == null || decorators.length < 1 ? undefined : decorators, modifiers == null || modifiers.length < 1 ? undefined : modifiers];
}
function normalizeNodeFactory(factory) {
    // By casting the factory to TypeScript 4.9.4, we're assuming to be on the last possible version where the decorators argument can still be separate from modifiers in the type definitions
    const ts4CastFactory = factory;
    if (Boolean(factory.__compatUpgraded)) {
        return factory;
    }
    // When this is true, this represents a TypeScript version where the the first argument to many of the factory functions is a list of decorators, which
    // has since been merged with modifiers
    let badDecoratorsAsFirstArgument = false;
    try {
        // This will throw on older TypeScript versions that always expect receiving decorators as the first argument
        badDecoratorsAsFirstArgument = ts4CastFactory.createImportEqualsDeclaration([], false, "", ts4CastFactory.createIdentifier("")).decorators != null;
    }
    catch {
        badDecoratorsAsFirstArgument = ts4CastFactory.createImportEqualsDeclaration([], [], false, "", ts4CastFactory.createIdentifier("")).decorators != null;
    }
    const badCreateImportEqualsDeclaration = badDecoratorsAsFirstArgument && factory.createImportEqualsDeclaration.length === 4;
    const badCreateImportSpecifier = badDecoratorsAsFirstArgument && factory.createImportSpecifier.length === 2;
    const badCreateExportSpecifier = badDecoratorsAsFirstArgument && factory.createExportSpecifier.length === 2;
    const badCreateImportTypeNode = badDecoratorsAsFirstArgument && factory.createImportTypeNode.length < 5;
    const badCreateMappedTypeNodeA = badDecoratorsAsFirstArgument && factory.createMappedTypeNode.length === 4;
    const badCreateMappedTypeNodeB = badDecoratorsAsFirstArgument && factory.createMappedTypeNode.length === 5;
    const badCreateTypeParameterDeclaration = badDecoratorsAsFirstArgument && factory.createTypeParameterDeclaration.length === 3;
    const missingCreateSatisfiesExpression = factory.createSatisfiesExpression == null;
    const missingCreateClassStaticBlockDeclaration = factory.createClassStaticBlockDeclaration == null;
    const missingCreateUniquePrivateName = factory.createUniquePrivateName == null;
    const missingGetGeneratedPrivateNameForNode = factory.getGeneratedPrivateNameForNode == null;
    const missingCreatePrivateIdentifier = factory.createPrivateIdentifier == null;
    const missingCreateAssertClause = factory.createAssertClause == null;
    const missingCreateAssertEntry = factory.createAssertEntry == null;
    const missingCreateImportTypeAssertionContainer = factory.createImportTypeAssertionContainer == null;
    const missingCreateJSDocMemberName = factory.createJSDocMemberName == null;
    const missingCreateJSDocLinkCode = factory.createJSDocLinkCode == null;
    const missingCreateJSDocLinkPlain = factory.createJSDocLinkPlain == null;
    const missingCreateJSDocOverloadTag = factory.createJSDocOverloadTag == null;
    const missingCreateJSDocThrowsTag = factory.createJSDocThrowsTag == null;
    const missingCreateJSDocSatisfiesTag = factory.createJSDocSatisfiesTag == null;
    const missingCreateJsxNamespacedName = factory.createJsxNamespacedName == null;
    const needsModifications = badCreateImportEqualsDeclaration ||
        badCreateImportSpecifier ||
        badCreateExportSpecifier ||
        badCreateImportTypeNode ||
        badCreateMappedTypeNodeA ||
        badCreateMappedTypeNodeB ||
        badCreateTypeParameterDeclaration ||
        missingCreateSatisfiesExpression ||
        missingCreateClassStaticBlockDeclaration ||
        missingCreateUniquePrivateName ||
        missingGetGeneratedPrivateNameForNode ||
        missingCreatePrivateIdentifier ||
        missingCreateAssertClause ||
        missingCreateAssertEntry ||
        missingCreateImportTypeAssertionContainer ||
        missingCreateJSDocMemberName ||
        missingCreateJSDocLinkCode ||
        missingCreateJSDocLinkPlain ||
        missingCreateJSDocOverloadTag ||
        missingCreateJSDocThrowsTag ||
        missingCreateJSDocSatisfiesTag ||
        missingCreateJsxNamespacedName ||
        badDecoratorsAsFirstArgument;
    if (needsModifications) {
        /**
         * The following helpers are internal TypeScript helpers that have been inlined for reuse inside factory helpers when the full TypeScript namespace is not available
         */
        const withOriginal = "original" in factory.updateBlock(factory.createBlock([]), []);
        const setOriginalNode = (node, original) => {
            node.original = original;
            return node;
        };
        const setTextRangeEnd = (range, end) => {
            range.end = end;
            return range;
        };
        const setTextRangePos = (range, pos) => {
            range.pos = pos;
            return range;
        };
        const setTextRangePosEnd = (range, pos, end) => setTextRangeEnd(setTextRangePos(range, pos), end);
        const setTextRange = (range, loc) => (loc != null ? setTextRangePosEnd(range, loc.pos, loc.end) : range);
        const updateWithoutOriginal = (updated, original) => {
            if (updated !== original) {
                setTextRange(updated, original);
            }
            return updated;
        };
        const updateWithOriginal = (updated, original) => {
            if (updated !== original) {
                setOriginalNode(updated, original);
                setTextRange(updated, original);
            }
            return updated;
        };
        const update = withOriginal ? updateWithOriginal : updateWithoutOriginal;
        const createPrivateIdentifier = missingCreatePrivateIdentifier
            ? (() => function (text) {
                const node = factory.createIdentifier(text);
                return node;
            })()
            : factory.createPrivateIdentifier;
        return {
            ["__compatUpgraded"]: true,
            ...factory,
            createPrivateIdentifier,
            ...(badCreateImportEqualsDeclaration
                ? (() => {
                    function createImportEqualsDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
                        const isShort = arguments.length <= 4;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
                        const name = (isShort ? isTypeOnlyOrName : nameOrModuleReference);
                        const moduleReference = (isShort ? nameOrModuleReference : moduleReferenceOrUndefined);
                        return factory.createImportEqualsDeclaration(decorators, modifiers, name, moduleReference);
                    }
                    function updateImportEqualsDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
                        const isShort = arguments.length <= 5;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
                        const name = (isShort ? isTypeOnlyOrName : nameOrModuleReference);
                        const moduleReference = (isShort ? nameOrModuleReference : moduleReferenceOrUndefined);
                        return factory.updateImportEqualsDeclaration(node, decorators, modifiers, name, moduleReference);
                    }
                    return {
                        createImportEqualsDeclaration,
                        updateImportEqualsDeclaration
                    };
                })()
                : {}),
            ...(badCreateImportSpecifier
                ? {
                    createImportSpecifier(isTypeOnly, propertyName, name) {
                        return factory.createImportSpecifier(propertyName, name);
                    },
                    updateImportSpecifier(node, isTypeOnly, propertyName, name) {
                        return factory.updateImportSpecifier(node, propertyName, name);
                    }
                }
                : {}),
            ...(badCreateExportSpecifier
                ? {
                    createExportSpecifier(isTypeOnly, propertyName, name) {
                        return factory.createExportSpecifier(propertyName, name);
                    },
                    updateExportSpecifier(node, isTypeOnly, propertyName, name) {
                        return factory.updateExportSpecifier(node, propertyName, name);
                    }
                }
                : {}),
            ...(badCreateImportTypeNode
                ? (() => {
                    function createImportTypeNode(argument, assertionsOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined) {
                        if (arguments.length < 5) {
                            return factory.createImportTypeNode(argument, assertionsOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf);
                        }
                        else {
                            return factory.createImportTypeNode(argument, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined);
                        }
                    }
                    function updateImportTypeNode(node, argument, assertionsOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined) {
                        if (arguments.length < 6) {
                            return factory.updateImportTypeNode(node, argument, assertionsOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf);
                        }
                        else {
                            return factory.updateImportTypeNode(node, argument, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined);
                        }
                    }
                    return { createImportTypeNode, updateImportTypeNode };
                })()
                : {}),
            ...(badCreateMappedTypeNodeA
                ? {
                    createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type) {
                        return factory.createMappedTypeNode(readonlyToken, typeParameter, questionToken, type);
                    },
                    updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type) {
                        return factory.updateMappedTypeNode(node, readonlyToken, typeParameter, questionToken, type);
                    }
                }
                : {}),
            ...(badCreateMappedTypeNodeB
                ? {
                    createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members) {
                        return factory.createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type);
                    },
                    updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type, members) {
                        return factory.updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type);
                    }
                }
                : {}),
            ...(badCreateTypeParameterDeclaration
                ? (() => {
                    function createTypeParameterDeclaration(modifiersOrName, nameOrConstraint, constraintOrDefaultType, defaultTypeOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
                        const modifiers = (isShort ? undefined : modifiersOrName);
                        const name = (isShort ? modifiersOrName : nameOrConstraint);
                        const constraint = (isShort ? nameOrConstraint : constraintOrDefaultType);
                        const defaultType = (isShort ? constraintOrDefaultType : defaultTypeOrUndefined);
                        const typeParameterDeclaration = factory.createTypeParameterDeclaration(name, constraint, defaultType);
                        if (modifiers != null) {
                            typeParameterDeclaration.modifiers = factory.createNodeArray(modifiers);
                        }
                        return typeParameterDeclaration;
                    }
                    function updateTypeParameterDeclaration(node, modifiersOrName, nameOrConstraint, constraintOrDefaultType, defaultTypeOrUndefined) {
                        const isShort = modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName; /* Identifier */
                        const modifiers = (isShort ? undefined : modifiersOrName);
                        const name = (isShort ? modifiersOrName : nameOrConstraint);
                        const constraint = (isShort ? nameOrConstraint : constraintOrDefaultType);
                        const defaultType = (isShort ? constraintOrDefaultType : defaultTypeOrUndefined);
                        const typeParameterDeclaration = factory.updateTypeParameterDeclaration(node, name, constraint, defaultType);
                        if (modifiers != null) {
                            typeParameterDeclaration.modifiers = factory.createNodeArray(modifiers);
                        }
                        return typeParameterDeclaration;
                    }
                    return {
                        createTypeParameterDeclaration,
                        updateTypeParameterDeclaration
                    };
                })()
                : {}),
            ...(missingCreateSatisfiesExpression
                ? (() => {
                    function createSatisfiesExpression(expression, type) {
                        return { ...expression };
                    }
                    function updateSatisfiesExpression(node, expression, type) {
                        return expression === node.expression && type === node.type ? node : update(createSatisfiesExpression(expression, type), node);
                    }
                    return {
                        createSatisfiesExpression,
                        updateSatisfiesExpression
                    };
                })()
                : {}),
            ...(missingCreateUniquePrivateName
                ? (() => {
                    function createUniquePrivateName(text) {
                        if (text != null && !text.startsWith("#")) {
                            throw new TypeError("First character of private identifier must be #: " + text);
                        }
                        const node = createPrivateIdentifier(text !== null && text !== void 0 ? text : "");
                        return node;
                    }
                    return {
                        createUniquePrivateName
                    };
                })()
                : {}),
            ...(missingGetGeneratedPrivateNameForNode
                ? (() => {
                    function getGeneratedPrivateNameForNode(node) {
                        return createPrivateIdentifier("");
                    }
                    return {
                        getGeneratedPrivateNameForNode
                    };
                })()
                : {}),
            ...(missingCreateClassStaticBlockDeclaration
                ? (() => {
                    function createClassStaticBlockDeclaration(decoratorsOrBlock, modifiersOrUndefined, bodyOrUndefined) {
                        const body = arguments.length >= 3 ? bodyOrUndefined : decoratorsOrBlock;
                        const node = factory.createEmptyStatement();
                        node.body = body;
                        node.transformFlags = 8388608 /* ContainsClassFields */;
                        return node;
                    }
                    function updateClassStaticBlockDeclaration(node, decoratorsOrBlock, modifiersOrUndefined, bodyOrUndefined) {
                        const body = arguments.length >= 4 ? bodyOrUndefined : decoratorsOrBlock;
                        return body === node.body ? node : update(createClassStaticBlockDeclaration(body), node);
                    }
                    return {
                        createClassStaticBlockDeclaration,
                        updateClassStaticBlockDeclaration
                    };
                })()
                : {}),
            ...(missingCreateAssertClause
                ? (() => {
                    function createAssertClause(elements, multiLine) {
                        const node = factory.createEmptyStatement();
                        node.elements = elements;
                        node.multiLine = multiLine;
                        node.transformFlags |= 4 /* ContainsESNext */;
                        return node;
                    }
                    function updateAssertClause(node, elements, multiLine) {
                        return node.elements !== elements || node.multiLine !== multiLine ? update(createAssertClause(elements, multiLine), node) : node;
                    }
                    return {
                        createAssertClause,
                        updateAssertClause
                    };
                })()
                : {}),
            ...(missingCreateAssertEntry
                ? (() => {
                    function createAssertEntry(name, value) {
                        const node = factory.createEmptyStatement();
                        node.name = name;
                        node.value = value;
                        node.transformFlags |= 4 /* ContainsESNext */;
                        return node;
                    }
                    function updateAssertEntry(node, name, value) {
                        return node.name !== name || node.value !== value ? update(createAssertEntry(name, value), node) : node;
                    }
                    return {
                        createAssertEntry,
                        updateAssertEntry
                    };
                })()
                : {}),
            ...(missingCreateImportTypeAssertionContainer
                ? (() => {
                    function createImportTypeAssertionContainer(clause, multiLine) {
                        const node = factory.createEmptyStatement();
                        node.assertClause = clause;
                        node.multiLine = multiLine;
                        return node;
                    }
                    function updateImportTypeAssertionContainer(node, clause, multiLine) {
                        return node.assertClause !== clause || node.multiLine !== multiLine ? update(createImportTypeAssertionContainer(clause, multiLine), node) : node;
                    }
                    return {
                        createImportTypeAssertionContainer,
                        updateImportTypeAssertionContainer
                    };
                })()
                : {}),
            ...(missingCreateJSDocMemberName
                ? (() => {
                    function createJSDocMemberName(left, right) {
                        const base = factory.createJSDocComment(undefined, undefined);
                        delete base.comment;
                        delete base.tags;
                        const node = base;
                        node.left = left;
                        node.right = right;
                        return node;
                    }
                    function updateJSDocMemberName(node, left, right) {
                        return left === node.left && right === node.right ? node : update(createJSDocMemberName(left, right), node);
                    }
                    return {
                        createJSDocMemberName,
                        updateJSDocMemberName
                    };
                })()
                : {}),
            ...(missingCreateJSDocLinkCode
                ? (() => {
                    function createJSDocLinkCode(name, text) {
                        const base = factory.createJSDocComment(undefined, undefined);
                        delete base.comment;
                        delete base.tags;
                        const node = base;
                        node.name = name;
                        node.text = text;
                        return node;
                    }
                    function updateJSDocLinkCode(node, name, text) {
                        return name === node.name && text === node.text ? node : update(createJSDocLinkCode(name, text), node);
                    }
                    return {
                        createJSDocLinkCode,
                        updateJSDocLinkCode
                    };
                })()
                : {}),
            ...(missingCreateJSDocLinkPlain
                ? (() => {
                    function createJSDocLinkPlain(name, text) {
                        const base = factory.createJSDocComment(undefined, undefined);
                        delete base.comment;
                        delete base.tags;
                        const node = base;
                        node.name = name;
                        node.text = text;
                        return node;
                    }
                    function updateJSDocLinkPlain(node, name, text) {
                        return name === node.name && text === node.text ? node : update(createJSDocLinkPlain(name, text), node);
                    }
                    return {
                        createJSDocLinkPlain,
                        updateJSDocLinkPlain
                    };
                })()
                : {}),
            ...(missingCreateJSDocOverloadTag
                ? (() => {
                    function createJSDocOverloadTag(tagName, typeExpression, comment) {
                        const base = factory.createJSDocComment(undefined, undefined);
                        delete base.comment;
                        delete base.tags;
                        const node = base;
                        if (tagName != null)
                            node.tagName = tagName;
                        node.typeExpression = typeExpression;
                        node.comment = comment;
                        return node;
                    }
                    function updateJSDocOverloadTag(node, tagName, typeExpression, comment) {
                        return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment
                            ? node
                            : update(createJSDocOverloadTag(tagName, typeExpression, comment), node);
                    }
                    return {
                        createJSDocOverloadTag,
                        updateJSDocOverloadTag
                    };
                })()
                : {}),
            ...(missingCreateJSDocThrowsTag
                ? (() => {
                    function createJSDocThrowsTag(tagName, typeExpression, comment) {
                        const base = factory.createJSDocComment(undefined, undefined);
                        delete base.comment;
                        delete base.tags;
                        const node = base;
                        if (tagName != null)
                            node.tagName = tagName;
                        node.typeExpression = typeExpression;
                        node.comment = comment;
                        return node;
                    }
                    function updateJSDocThrowsTag(node, tagName, typeExpression, comment) {
                        return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment
                            ? node
                            : update(createJSDocThrowsTag(tagName !== null && tagName !== void 0 ? tagName : node.tagName, typeExpression, comment), node);
                    }
                    return {
                        createJSDocThrowsTag,
                        updateJSDocThrowsTag
                    };
                })()
                : {}),
            ...(missingCreateJSDocSatisfiesTag
                ? (() => {
                    function createJSDocSatisfiesTag(tagName, typeExpression, comment) {
                        const base = factory.createJSDocComment(undefined, undefined);
                        delete base.comment;
                        delete base.tags;
                        const node = base;
                        if (tagName != null)
                            node.tagName = tagName;
                        node.typeExpression = typeExpression;
                        node.comment = comment;
                        return node;
                    }
                    function updateJSDocSatisfiesTag(node, tagName, typeExpression, comment) {
                        return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment
                            ? node
                            : update(createJSDocSatisfiesTag(tagName, typeExpression, comment), node);
                    }
                    return {
                        createJSDocSatisfiesTag,
                        updateJSDocSatisfiesTag
                    };
                })()
                : {}),
            ...(missingCreateJsxNamespacedName
                ? (() => {
                    function createJsxNamespacedName(namespace, name) {
                        const node = factory.createEmptyStatement();
                        node.namespace = namespace;
                        node.name = name;
                        return node;
                    }
                    function updateJsxNamespacedName(node, namespace, name) {
                        return node.namespace !== namespace || node.name !== name ? update(createJsxNamespacedName(namespace, name), node) : node;
                    }
                    return {
                        createJsxNamespacedName,
                        updateJsxNamespacedName
                    };
                })()
                : {}),
            ...(badDecoratorsAsFirstArgument
                ? (() => {
                    function createParameterDeclaration(decoratorsOrModifiers, modifiersOrDotDotDotToken, dotDotDotTokenOrName, nameOrQuestionToken, questionTokenOrType, typeOrInitializer, initializerOrUndefined) {
                        const isShort = typeof dotDotDotTokenOrName === "string" || (dotDotDotTokenOrName != null && dotDotDotTokenOrName.kind !== 25); /* DotDotDotToken */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort
                            ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1]
                            : modifiersOrDotDotDotToken;
                        const dotDotDotToken = (isShort ? modifiersOrDotDotDotToken : dotDotDotTokenOrName);
                        const name = (isShort ? dotDotDotTokenOrName : nameOrQuestionToken);
                        const questionToken = (isShort ? nameOrQuestionToken : questionTokenOrType);
                        const type = (isShort ? questionTokenOrType : typeOrInitializer);
                        const initializer = (isShort ? typeOrInitializer : initializerOrUndefined);
                        return factory.createParameterDeclaration(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer);
                    }
                    function updateParameterDeclaration(node, decoratorsOrModifiers, modifiersOrDotDotDotToken, dotDotDotTokenOrName, nameOrQuestionToken, questionTokenOrType, typeOrInitializer, initializerOrUndefined) {
                        const isShort = typeof dotDotDotTokenOrName === "string" || (dotDotDotTokenOrName != null && dotDotDotTokenOrName.kind !== 25); /* DotDotDotToken */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort
                            ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1]
                            : modifiersOrDotDotDotToken;
                        const dotDotDotToken = (isShort ? modifiersOrDotDotDotToken : dotDotDotTokenOrName);
                        const name = (isShort ? dotDotDotTokenOrName : nameOrQuestionToken);
                        const questionToken = (isShort ? nameOrQuestionToken : questionTokenOrType);
                        const type = (isShort ? questionTokenOrType : typeOrInitializer);
                        const initializer = (isShort ? typeOrInitializer : initializerOrUndefined);
                        return factory.updateParameterDeclaration(node, decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer);
                    }
                    function createPropertyDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrQuestionOrExclamationToken, questionOrExclamationTokenOrType, typeOrInitializer, initializerOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrQuestionOrExclamationToken);
                        const questionOrExclamationToken = (isShort ? nameOrQuestionOrExclamationToken : questionOrExclamationTokenOrType);
                        const type = (isShort ? questionOrExclamationTokenOrType : typeOrInitializer);
                        const initializer = (isShort ? typeOrInitializer : initializerOrUndefined);
                        return factory.createPropertyDeclaration(decorators, modifiers, name, questionOrExclamationToken, type, initializer);
                    }
                    function updatePropertyDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrQuestionOrExclamationToken, questionOrExclamationTokenOrType, typeOrInitializer, initializerOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrQuestionOrExclamationToken);
                        const questionOrExclamationToken = (isShort ? nameOrQuestionOrExclamationToken : questionOrExclamationTokenOrType);
                        const type = (isShort ? questionOrExclamationTokenOrType : typeOrInitializer);
                        const initializer = (isShort ? typeOrInitializer : initializerOrUndefined);
                        return factory.updatePropertyDeclaration(node, decorators, modifiers, name, questionOrExclamationToken, type, initializer);
                    }
                    function createMethodDeclaration(decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrQuestionToken, questionTokenOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
                        const isShort = typeof asteriskTokenOrName === "string" || (asteriskTokenOrName != null && asteriskTokenOrName.kind !== 41); /* AsteriskToken */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort
                            ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1]
                            : modifiersOrAsteriskToken;
                        const asteriskToken = (isShort ? modifiersOrAsteriskToken : asteriskTokenOrName);
                        const name = (isShort ? asteriskTokenOrName : nameOrQuestionToken);
                        const questionToken = (isShort ? nameOrQuestionToken : questionTokenOrTypeParameters);
                        const typeParameters = (isShort ? questionTokenOrTypeParameters : typeParametersOrParameters);
                        const parameters = (isShort ? typeParametersOrParameters : parametersOrType);
                        const type = (isShort ? parametersOrType : typeOrBody);
                        const body = (isShort ? typeOrBody : bodyOrUndefined);
                        return factory.createMethodDeclaration(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body);
                    }
                    function updateMethodDeclaration(node, decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrQuestionToken, questionTokenOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
                        const isShort = typeof asteriskTokenOrName === "string" || (asteriskTokenOrName != null && asteriskTokenOrName.kind !== 41); /* AsteriskToken */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort
                            ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1]
                            : modifiersOrAsteriskToken;
                        const asteriskToken = (isShort ? modifiersOrAsteriskToken : asteriskTokenOrName);
                        const name = (isShort ? asteriskTokenOrName : nameOrQuestionToken);
                        const questionToken = (isShort ? nameOrQuestionToken : questionTokenOrTypeParameters);
                        const typeParameters = (isShort ? questionTokenOrTypeParameters : typeParametersOrParameters);
                        const parameters = (isShort ? typeParametersOrParameters : parametersOrType);
                        const type = (isShort ? parametersOrType : typeOrBody);
                        const body = (isShort ? typeOrBody : bodyOrUndefined);
                        return factory.updateMethodDeclaration(node, decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body);
                    }
                    function createConstructorDeclaration(decoratorsOrModifiers, modifiersOrParameters, parametersOrBody, bodyOrUndefined) {
                        const isShort = arguments.length <= 3;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
                        const parameters = (isShort ? modifiersOrParameters : parametersOrBody);
                        const body = (isShort ? parametersOrBody : bodyOrUndefined);
                        return factory.createConstructorDeclaration(decorators, modifiers, parameters, body);
                    }
                    function updateConstructorDeclaration(node, decoratorsOrModifiers, modifiersOrParameters, parametersOrBody, bodyOrUndefined) {
                        const isShort = arguments.length <= 4;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
                        const parameters = (isShort ? modifiersOrParameters : parametersOrBody);
                        const body = (isShort ? parametersOrBody : bodyOrUndefined);
                        return factory.updateConstructorDeclaration(node, decorators, modifiers, parameters, body);
                    }
                    function createGetAccessorDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrParameters);
                        const parameters = (isShort ? nameOrParameters : parametersOrType);
                        const type = (isShort ? parametersOrType : typeOrBody);
                        const body = (isShort ? typeOrBody : bodyOrUndefined);
                        return factory.createGetAccessorDeclaration(decorators, modifiers, name, parameters, type, body);
                    }
                    function updateGetAccessorDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrParameters);
                        const parameters = (isShort ? nameOrParameters : parametersOrType);
                        const type = (isShort ? parametersOrType : typeOrBody);
                        const body = (isShort ? typeOrBody : bodyOrUndefined);
                        return factory.updateGetAccessorDeclaration(node, decorators, modifiers, name, parameters, type, body);
                    }
                    function createSetAccessorDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrBody, bodyOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrParameters);
                        const parameters = (isShort ? nameOrParameters : parametersOrBody);
                        const body = (isShort ? parametersOrBody : bodyOrUndefined);
                        return factory.createSetAccessorDeclaration(decorators, modifiers, name, parameters, body);
                    }
                    function updateSetAccessorDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrBody, bodyOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrParameters);
                        const parameters = (isShort ? nameOrParameters : parametersOrBody);
                        const body = (isShort ? parametersOrBody : bodyOrUndefined);
                        return factory.updateSetAccessorDeclaration(node, decorators, modifiers, name, parameters, body);
                    }
                    function createIndexSignature(decoratorsOrModifiers, modifiersOrParameters, parametersOrType, typeOrUndefined) {
                        const isShort = arguments.length <= 3;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
                        const parameters = (isShort ? modifiersOrParameters : parametersOrType);
                        const type = (isShort ? parametersOrType : typeOrUndefined);
                        return factory.createIndexSignature(decorators, modifiers, parameters, type);
                    }
                    function updateIndexSignature(node, decoratorsOrModifiers, modifiersOrParameters, parametersOrType, typeOrUndefined) {
                        const isShort = arguments.length <= 4;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
                        const parameters = (isShort ? modifiersOrParameters : parametersOrType);
                        const type = (isShort ? parametersOrType : typeOrUndefined);
                        return factory.updateIndexSignature(node, decorators, modifiers, parameters, type);
                    }
                    function createClassStaticBlockDeclaration(decoratorsOrBody, modifiersOrUndefined, bodyOrUndefined) {
                        const isShort = arguments.length <= 1;
                        const body = (isShort ? decoratorsOrBody : bodyOrUndefined);
                        if (missingCreateClassStaticBlockDeclaration) {
                            const node = factory.createEmptyStatement();
                            node.body = body;
                            node.transformFlags = 8388608 /* ContainsClassFields */;
                            return node;
                        }
                        else {
                            return ts4CastFactory.createClassStaticBlockDeclaration(undefined, undefined, body);
                        }
                    }
                    function updateClassStaticBlockDeclaration(node, decoratorsOrBody, modifiersOrUndefined, bodyOrUndefined) {
                        const isShort = arguments.length <= 2;
                        const body = (isShort ? decoratorsOrBody : bodyOrUndefined);
                        if (missingCreateClassStaticBlockDeclaration) {
                            return body === node.body ? node : update(createClassStaticBlockDeclaration(body), node);
                        }
                        else {
                            return ts4CastFactory.updateClassStaticBlockDeclaration(node, undefined, undefined, body);
                        }
                    }
                    function createClassExpression(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
                        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
                        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
                        return factory.createClassExpression(decorators, modifiers, name, typeParameters, heritageClauses, members);
                    }
                    function updateClassExpression(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
                        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
                        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
                        return factory.updateClassExpression(node, decorators, modifiers, name, typeParameters, heritageClauses, members);
                    }
                    function createFunctionDeclaration(decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
                        const isShort = arguments.length <= 7;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort
                            ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1]
                            : modifiersOrAsteriskToken;
                        const asteriskToken = (isShort ? modifiersOrAsteriskToken : asteriskTokenOrName);
                        const name = (isShort ? asteriskTokenOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrParameters);
                        const parameters = (isShort ? typeParametersOrParameters : parametersOrType);
                        const type = (isShort ? parametersOrType : typeOrBody);
                        const body = (isShort ? typeOrBody : bodyOrUndefined);
                        return factory.createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body);
                    }
                    function updateFunctionDeclaration(node, decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
                        const isShort = arguments.length <= 8;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort
                            ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1]
                            : modifiersOrAsteriskToken;
                        const asteriskToken = (isShort ? modifiersOrAsteriskToken : asteriskTokenOrName);
                        const name = (isShort ? asteriskTokenOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrParameters);
                        const parameters = (isShort ? typeParametersOrParameters : parametersOrType);
                        const type = (isShort ? parametersOrType : typeOrBody);
                        const body = (isShort ? typeOrBody : bodyOrUndefined);
                        return factory.updateFunctionDeclaration(node, decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body);
                    }
                    function createClassDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
                        const isShort = arguments.length <= 5;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
                        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
                        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
                        return factory.createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
                    }
                    function updateClassDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
                        const isShort = arguments.length <= 6;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
                        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
                        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
                        return factory.updateClassDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members);
                    }
                    function createInterfaceDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
                        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
                        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
                        return factory.createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
                    }
                    function updateInterfaceDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
                        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
                        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
                        return factory.updateInterfaceDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members);
                    }
                    function createTypeAliasDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrType, typeOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrType);
                        const type = (isShort ? typeParametersOrType : typeOrUndefined);
                        return factory.createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type);
                    }
                    function updateTypeAliasDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrType, typeOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
                        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrType);
                        const type = (isShort ? typeParametersOrType : typeOrUndefined);
                        return factory.updateTypeAliasDeclaration(node, decorators, modifiers, name, typeParameters, type);
                    }
                    function createEnumDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrMembers, membersOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrMembers);
                        const members = (isShort ? nameOrMembers : membersOrUndefined);
                        return factory.createEnumDeclaration(decorators, modifiers, name, members);
                    }
                    function updateEnumDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrMembers, membersOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrMembers);
                        const members = (isShort ? nameOrMembers : membersOrUndefined);
                        return factory.updateEnumDeclaration(node, decorators, modifiers, name, members);
                    }
                    function createModuleDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrBody, bodyOrFlags, flagsOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" ||
                            (modifiersOrName != null &&
                                !Array.isArray(modifiersOrName) &&
                                ("escapedText" in modifiersOrName /* Identifier */ || "_literalExpressionBrand" in modifiersOrName)); /* StringLiteral */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrBody);
                        const body = (isShort ? nameOrBody : bodyOrFlags);
                        const flags = (isShort ? bodyOrFlags : flagsOrUndefined);
                        return factory.createModuleDeclaration(decorators, modifiers, name, body, flags);
                    }
                    function updateModuleDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrBody, bodyOrUndefined) {
                        const isShort = typeof modifiersOrName === "string" ||
                            (modifiersOrName != null &&
                                !Array.isArray(modifiersOrName) &&
                                ("escapedText" in modifiersOrName /* Identifier */ || "_literalExpressionBrand" in modifiersOrName)); /* StringLiteral */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
                        const name = (isShort ? modifiersOrName : nameOrBody);
                        const body = (isShort ? nameOrBody : bodyOrUndefined);
                        return factory.updateModuleDeclaration(node, decorators, modifiers, name, body);
                    }
                    function createImportEqualsDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
                        var _a;
                        const isShort = arguments.length <= 4;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
                        const isTypeOnly = (_a = (isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrName)) !== null && _a !== void 0 ? _a : false;
                        const name = (isShort ? isTypeOnlyOrName : nameOrModuleReference);
                        const moduleReference = (isShort ? nameOrModuleReference : moduleReferenceOrUndefined);
                        if (badCreateImportEqualsDeclaration) {
                            return factory.createImportEqualsDeclaration(decorators, modifiers, name, moduleReference);
                        }
                        else {
                            return factory.createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, name, moduleReference);
                        }
                    }
                    function updateImportEqualsDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
                        const isShort = arguments.length <= 5;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
                        const isTypeOnly = (isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrName);
                        const name = (isShort ? isTypeOnlyOrName : nameOrModuleReference);
                        const moduleReference = (isShort ? nameOrModuleReference : moduleReferenceOrUndefined);
                        if (badCreateImportEqualsDeclaration) {
                            return factory.updateImportEqualsDeclaration(node, decorators, modifiers, name, moduleReference);
                        }
                        else {
                            return factory.updateImportEqualsDeclaration(node, decorators, modifiers, isTypeOnly, name, moduleReference);
                        }
                    }
                    function createImportDeclaration(decoratorsOrModifiers, modifiersOrImportClause, importClauseOrModuleSpecifier, moduleSpecifierOrAssertClause, assertClauseOrUndefined) {
                        const isShort = modifiersOrImportClause != null && !Array.isArray(modifiersOrImportClause);
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrImportClause;
                        const importClause = (isShort ? modifiersOrImportClause : importClauseOrModuleSpecifier);
                        const moduleSpecifier = (isShort ? importClauseOrModuleSpecifier : moduleSpecifierOrAssertClause);
                        const assertClause = (isShort ? moduleSpecifierOrAssertClause : assertClauseOrUndefined);
                        return factory.createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier, assertClause);
                    }
                    function updateImportDeclaration(node, decoratorsOrModifiers, modifiersOrImportClause, importClauseOrModuleSpecifier, moduleSpecifierOrAssertClause, assertClauseOrUndefined) {
                        const isShort = importClauseOrModuleSpecifier != null && importClauseOrModuleSpecifier.kind !== 267; /* ImportClause */
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrImportClause;
                        const importClause = (isShort ? modifiersOrImportClause : importClauseOrModuleSpecifier);
                        const moduleSpecifier = (isShort ? importClauseOrModuleSpecifier : moduleSpecifierOrAssertClause);
                        const assertClause = (isShort ? moduleSpecifierOrAssertClause : assertClauseOrUndefined);
                        return factory.updateImportDeclaration(node, decorators, modifiers, importClause, moduleSpecifier, assertClause);
                    }
                    function createExportAssignment(decoratorsOrModifiers, modifiersOrIsExportEquals, isExportEqualsOrExpression, expressionOrUndefined) {
                        const isShort = arguments.length <= 3;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort
                            ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1]
                            : modifiersOrIsExportEquals;
                        const isExportEquals = (isShort ? modifiersOrIsExportEquals : isExportEqualsOrExpression);
                        const expression = (isShort ? isExportEqualsOrExpression : expressionOrUndefined);
                        return factory.createExportAssignment(decorators, modifiers, isExportEquals, expression);
                    }
                    function updateExportAssignment(node, decoratorsOrModifiers, modifiersOrExpression, expressionOrUndefined) {
                        const isShort = arguments.length <= 3;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrExpression;
                        const expression = (isShort ? modifiersOrExpression : expressionOrUndefined);
                        return factory.updateExportAssignment(node, decorators, modifiers, expression);
                    }
                    function createExportDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrExportClause, exportClauseOrModuleSpecifier, moduleSpecifierOrAssertClause, assertClauseOrUndefined) {
                        const isLong = typeof modifiersOrIsTypeOnly !== "boolean" && (arguments.length >= 6 || Array.isArray(modifiersOrIsTypeOnly));
                        const isShort = !isLong;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
                        const isTypeOnly = (isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrExportClause);
                        const exportClause = (isShort ? isTypeOnlyOrExportClause : exportClauseOrModuleSpecifier);
                        const moduleSpecifier = (isShort ? exportClauseOrModuleSpecifier : moduleSpecifierOrAssertClause);
                        const assertClause = (isShort ? moduleSpecifierOrAssertClause : assertClauseOrUndefined);
                        return factory.createExportDeclaration(decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause);
                    }
                    function updateExportDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrExportClause, exportClauseOrModuleSpecifier, moduleSpecifierOrAssertClause, assertClauseOrUndefined) {
                        const isLong = typeof modifiersOrIsTypeOnly !== "boolean" && (arguments.length >= 7 || Array.isArray(modifiersOrIsTypeOnly));
                        const isShort = !isLong;
                        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
                        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
                        const isTypeOnly = (isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrExportClause);
                        const exportClause = (isShort ? isTypeOnlyOrExportClause : exportClauseOrModuleSpecifier);
                        const moduleSpecifier = (isShort ? exportClauseOrModuleSpecifier : moduleSpecifierOrAssertClause);
                        const assertClause = (isShort ? moduleSpecifierOrAssertClause : assertClauseOrUndefined);
                        return factory.updateExportDeclaration(node, decorators, modifiers, isTypeOnly, exportClause, moduleSpecifier, assertClause);
                    }
                    return {
                        createParameterDeclaration,
                        updateParameterDeclaration,
                        createPropertyDeclaration,
                        updatePropertyDeclaration,
                        createMethodDeclaration,
                        updateMethodDeclaration,
                        createConstructorDeclaration,
                        updateConstructorDeclaration,
                        createGetAccessorDeclaration,
                        updateGetAccessorDeclaration,
                        createSetAccessorDeclaration,
                        updateSetAccessorDeclaration,
                        createIndexSignature,
                        updateIndexSignature,
                        createClassStaticBlockDeclaration,
                        updateClassStaticBlockDeclaration,
                        createClassExpression,
                        updateClassExpression,
                        createFunctionDeclaration,
                        updateFunctionDeclaration,
                        createClassDeclaration,
                        updateClassDeclaration,
                        createInterfaceDeclaration,
                        updateInterfaceDeclaration,
                        createTypeAliasDeclaration,
                        updateTypeAliasDeclaration,
                        createEnumDeclaration,
                        updateEnumDeclaration,
                        createModuleDeclaration,
                        updateModuleDeclaration,
                        createImportEqualsDeclaration,
                        updateImportEqualsDeclaration,
                        createImportDeclaration,
                        updateImportDeclaration,
                        createExportAssignment,
                        updateExportAssignment,
                        createExportDeclaration,
                        updateExportDeclaration
                    };
                })()
                : {})
        };
    }
    return factory;
}
function createNodeFactory(typescript) {
    var _a;
    const typescript4Cast = typescript;
    function createToken(token) {
        return typescript4Cast.createToken(token);
    }
    function createConstructorTypeNode(modifiersOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrUndefined) {
        if (arguments.length >= 4) {
            return typescript4Cast.createConstructorTypeNode(typeParametersOrParameters, parametersOrType, typeOrUndefined);
        }
        return typescript4Cast.createConstructorTypeNode(modifiersOrTypeParameters, typeParametersOrParameters, parametersOrType);
    }
    function updateConstructorTypeNode(node, modifiersOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrUndefined) {
        if (arguments.length >= 5) {
            return typescript4Cast.updateConstructorTypeNode(node, typeParametersOrParameters, parametersOrType, typeOrUndefined);
        }
        return typescript4Cast.updateConstructorTypeNode(node, modifiersOrTypeParameters, typeParametersOrParameters, parametersOrType);
    }
    function createNamedTupleMember(dotDotDotToken, name, questionToken, type) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.NamedTupleMember) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.TupleType));
        node.dotDotDotToken = dotDotDotToken;
        node.name = name;
        node.questionToken = questionToken;
        node.type = type;
        node.transformFlags = 1 /* ContainsTypeScript */;
        return node;
    }
    function createJSDocComment(comment, tags) {
        if ("createJSDocComment" in typescript) {
            return typescript4Cast.createJSDocComment(comment, tags);
        }
        const node = typescript4Cast.createNode(typescript.SyntaxKind.JSDocComment);
        node.comment = comment;
        node.tags = typescript4Cast.createNodeArray(tags);
        return node;
    }
    function createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
        var _a;
        if ("createJSDocParameterTag" in typescript) {
            return typescript4Cast.createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocParameterTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.name = name;
        node.isBracketed = isBracketed;
        node.typeExpression = typeExpression;
        if (isNameFirst != null)
            node.isNameFirst = isNameFirst;
        node.comment = comment;
        return node;
    }
    function createJSDocPrivateTag(tagName, comment) {
        var _a;
        if ("createJSDocPrivateTag" in typescript) {
            return typescript4Cast.createJSDocPrivateTag(tagName, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocPrivateTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.comment = comment;
        return node;
    }
    function createJSDocAugmentsTag(tagName, className, comment) {
        var _a;
        if ("createJSDocAugmentsTag" in typescript) {
            return typescript4Cast.createJSDocAugmentsTag(tagName, className, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocAugmentsTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.class = className;
        node.comment = comment;
        return node;
    }
    function createJSDocDeprecatedTag(tagName, comment) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocDeprecatedTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.tagName = tagName;
        node.comment = comment;
        return node;
    }
    function createJSDocFunctionType(parameters, type) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocFunctionType) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.parameters = typescript4Cast.createNodeArray(parameters);
        node.type = type;
        return node;
    }
    function createJSDocLink(name, text) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocLink) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.name = name;
        node.text = text;
        return node;
    }
    function createJSDocNameReference(name) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocNameReference) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.name = name;
        return node;
    }
    function createJSDocNamepathType(type) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocNamepathType) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.type = type;
        return node;
    }
    function createJSDocNonNullableType(type) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocNonNullableType) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.type = type;
        return node;
    }
    function createJSDocNullableType(type) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocNullableType) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.type = type;
        return node;
    }
    function createJSDocOptionalType(type) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocOptionalType) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.type = type;
        return node;
    }
    function createJSDocOverrideTag(tagName, comment) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocOverrideTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.tagName = tagName;
        node.comment = comment;
        return node;
    }
    function createJSDocSeeTag(tagName, nameExpression, comment) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocSeeTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null) {
            node.tagName = tagName;
        }
        node.name = nameExpression;
        node.comment = comment;
        return node;
    }
    function createJSDocText(text) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocText) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.text = text;
        return node;
    }
    function createJSDocUnknownTag(tagName, comment) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.tagName = tagName;
        node.comment = comment;
        return node;
    }
    function createJSDocUnknownType() {
        var _a;
        return typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocUnknownType) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
    }
    function createJSDocVariadicType(type) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocVariadicType) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.type = type;
        return node;
    }
    function createJSDocAllType() {
        var _a;
        return typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocAllType) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
    }
    function createTemplateLiteralType(head, templateSpans) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.TemplateLiteralType) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.StringLiteral));
        node.head = head;
        node.templateSpans = typescript4Cast.createNodeArray(templateSpans);
        node.transformFlags = 1 /* ContainsTypeScript */;
        return node;
    }
    function createTemplateLiteralTypeSpan(type, literal) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.TemplateLiteralTypeSpan) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.StringLiteral));
        node.type = type;
        node.literal = literal;
        node.transformFlags = 1 /* ContainsTypeScript */;
        return node;
    }
    function createJSDocAuthorTag(tagName, comment) {
        var _a;
        if ("createJSDocAuthorTag" in typescript) {
            return typescript4Cast.createJSDocAuthorTag(tagName, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocAuthorTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.comment = comment;
        return node;
    }
    function createJSDocCallbackTag(tagName, typeExpression, fullName, comment) {
        var _a;
        if ("createJSDocCallbackTag" in typescript) {
            return typescript4Cast.createJSDocCallbackTag(tagName, typeExpression, fullName, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocCallbackTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.typeExpression = typeExpression;
        node.fullName = fullName;
        node.comment = comment;
        return node;
    }
    function createJSDocClassTag(tagName, comment) {
        var _a;
        if ("createJSDocClassTag" in typescript) {
            return typescript4Cast.createJSDocClassTag(tagName, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocClassTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.comment = comment;
        return node;
    }
    function createJSDocEnumTag(tagName, typeExpression, comment) {
        var _a;
        if ("createJSDocEnumTag" in typescript) {
            return typescript4Cast.createJSDocEnumTag(tagName, typeExpression, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocEnumTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.typeExpression = typeExpression;
        node.comment = comment;
        return node;
    }
    function createJSDocImplementsTag(tagName, className, comment) {
        var _a;
        if ("createJSDocImplementsTag" in typescript) {
            return typescript4Cast.createJSDocImplementsTag(tagName, className, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocImplementsTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.class = className;
        node.comment = comment;
        return node;
    }
    function createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
        var _a;
        if ("createJSDocPropertyTag" in typescript) {
            return typescript4Cast.createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocPropertyTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.name = name;
        node.isBracketed = isBracketed;
        node.typeExpression = typeExpression;
        if (isNameFirst != null)
            node.isNameFirst = isNameFirst;
        node.comment = comment;
        return node;
    }
    function createJSDocProtectedTag(tagName, comment) {
        var _a;
        if ("createJSDocProtectedTag" in typescript) {
            return typescript4Cast.createJSDocProtectedTag(tagName, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocProtectedTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.comment = comment;
        return node;
    }
    function createJSDocPublicTag(tagName, comment) {
        var _a;
        if ("createJSDocPublicTag" in typescript) {
            return typescript4Cast.createJSDocPublicTag(tagName, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocPublicTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.comment = comment;
        return node;
    }
    function createJSDocReadonlyTag(tagName, comment) {
        var _a;
        if ("createJSDocReadonlyTag" in typescript) {
            return typescript4Cast.createJSDocReadonlyTag(tagName, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocReadonlyTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.comment = comment;
        return node;
    }
    function createJSDocReturnTag(tagName, typeExpression, comment) {
        var _a;
        if ("createJSDocReturnTag" in typescript) {
            return typescript4Cast.createJSDocReturnTag(tagName, typeExpression, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocReturnTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.typeExpression = typeExpression;
        node.comment = comment;
        return node;
    }
    function createJSDocSignature(typeParameters, parameters, type) {
        var _a;
        if ("createJSDocSignature" in typescript) {
            return typescript4Cast.createJSDocSignature(typeParameters, parameters, type);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocSignature) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.typeParameters = typeParameters;
        node.parameters = parameters;
        node.type = type;
        return node;
    }
    function createJSDocTemplateTag(tagName, constraint, typeParameters, comment) {
        var _a;
        if ("createJSDocTemplateTag" in typescript) {
            return typescript4Cast.createJSDocTemplateTag(tagName, constraint, typeParameters, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocTemplateTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.constraint = constraint;
        node.typeParameters = typescript4Cast.createNodeArray(typeParameters);
        node.comment = comment;
        return node;
    }
    function createJSDocThisTag(tagName, typeExpression, comment) {
        var _a;
        if ("createJSDocThisTag" in typescript) {
            return typescript4Cast.createJSDocThisTag(tagName, typeExpression, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocThisTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.typeExpression = typeExpression;
        node.comment = comment;
        return node;
    }
    function createJSDocTypeExpression(type) {
        var _a;
        if ("createJSDocTypeExpression" in typescript) {
            return typescript4Cast.createJSDocTypeExpression(type);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocTypeExpression) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.type = type;
        return node;
    }
    function createJSDocTypeLiteral(jsDocPropertyTags, isArrayType) {
        var _a;
        if ("createJSDocTypeLiteral" in typescript) {
            return typescript4Cast.createJSDocTypeLiteral(jsDocPropertyTags, isArrayType);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocTypeLiteral) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.jsDocPropertyTags = jsDocPropertyTags;
        if (isArrayType != null)
            node.isArrayType = isArrayType;
        return node;
    }
    function createJSDocTypeTag(tagName, typeExpression, comment) {
        var _a;
        if ("createJSDocTypeTag" in typescript) {
            return typescript4Cast.createJSDocTypeTag(tagName, typeExpression, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocTypeTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.typeExpression = typeExpression;
        node.comment = comment;
        return node;
    }
    function createJSDocTypedefTag(tagName, typeExpression, fullName, comment) {
        var _a;
        if ("createJSDocTypedefTag" in typescript) {
            return typescript4Cast.createJSDocTypedefTag(tagName, typeExpression, fullName, comment);
        }
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocTypedefTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.typeExpression = typeExpression;
        node.fullName = fullName;
        node.comment = comment;
        return node;
    }
    function createJSDocMemberName(left, right) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocMemberName) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.left = left;
        node.right = right;
        return node;
    }
    function createJSDocLinkCode(name, text) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocLinkCode) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.name = name;
        node.text = text;
        return node;
    }
    function createJSDocLinkPlain(name, text) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocLinkPlain) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        node.name = name;
        node.text = text;
        return node;
    }
    function createJSDocOverloadTag(tagName, typeExpression, comment) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocOverloadTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.typeExpression = typeExpression;
        node.comment = comment;
        return node;
    }
    function createJSDocThrowsTag(tagName, typeExpression, comment) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocThrowsTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.typeExpression = typeExpression;
        node.comment = comment;
        return node;
    }
    function createJSDocSatisfiesTag(tagName, typeExpression, comment) {
        var _a;
        const node = typescript4Cast.createNode(((_a = typescript.SyntaxKind.JSDocSatisfiesTag) !== null && _a !== void 0 ? _a : typescript.SyntaxKind.JSDocComment));
        if (tagName != null)
            node.tagName = tagName;
        node.typeExpression = typeExpression;
        node.comment = comment;
        return node;
    }
    function createClassStaticBlockDeclaration(decoratorsOrBody, modifiersOrUndefined, bodyOrUndefined) {
        const isShort = arguments.length <= 1;
        const body = (isShort ? decoratorsOrBody : bodyOrUndefined);
        const node = typescript4Cast.createEmptyStatement();
        node.body = body;
        node.transformFlags = 8388608 /* ContainsClassFields */;
        return node;
    }
    function updateClassStaticBlockDeclaration(node, decoratorsOrBody, modifiersOrUndefined, bodyOrUndefined) {
        const isShort = arguments.length <= 2;
        const body = (isShort ? decoratorsOrBody : bodyOrUndefined);
        return body === node.body ? node : typescript.setTextRange(createClassStaticBlockDeclaration(body), node);
    }
    function createSatisfiesExpression(expression, type) {
        return { ...expression };
    }
    function updateSatisfiesExpression(node, expression, type) {
        return expression === node.expression && type === node.type ? node : typescript.setTextRange(createSatisfiesExpression(expression, type), node);
    }
    function createAssertClause(elements, multiLine) {
        const node = typescript4Cast.createEmptyStatement();
        node.elements = elements;
        node.multiLine = multiLine;
        node.transformFlags |= 4 /* ContainsESNext */;
        return node;
    }
    function createAssertEntry(name, value) {
        const node = typescript4Cast.createEmptyStatement();
        node.name = name;
        node.value = value;
        node.transformFlags |= 4 /* ContainsESNext */;
        return node;
    }
    function createImportTypeAssertionContainer(clause, multiLine) {
        const node = typescript4Cast.createEmptyStatement();
        node.assertClause = clause;
        node.multiLine = multiLine;
        return node;
    }
    function createJsxNamespacedName(namespace, name) {
        const node = typescript4Cast.createEmptyStatement();
        node.namespace = namespace;
        node.name = name;
        return node;
    }
    function createImportTypeNode(argument, assertionsOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined) {
        if ("createImportTypeNode" in typescript) {
            if (arguments.length < 5) {
                return typescript4Cast.createImportTypeNode(argument, assertionsOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf);
            }
            else {
                return typescript4Cast.createImportTypeNode(argument, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined);
            }
        }
        else {
            const assertion = assertionsOrQualifier && "assertClause" in assertionsOrQualifier ? assertionsOrQualifier : undefined;
            const qualifier = (assertionsOrQualifier && typescript.isEntityName(assertionsOrQualifier)
                ? assertionsOrQualifier
                : qualifierOrTypeArguments && !Array.isArray(qualifierOrTypeArguments)
                    ? qualifierOrTypeArguments
                    : undefined);
            const typeArguments = (Array.isArray(qualifierOrTypeArguments) ? qualifierOrTypeArguments : Array.isArray(typeArgumentsOrIsTypeOf) ? typeArgumentsOrIsTypeOf : undefined);
            isTypeOfOrUndefined = typeof typeArgumentsOrIsTypeOf === "boolean" ? typeArgumentsOrIsTypeOf : typeof isTypeOfOrUndefined === "boolean" ? isTypeOfOrUndefined : false;
            const node = typescript4Cast.createNode(200);
            node.argument = argument;
            node.assertions = assertion;
            node.qualifier = qualifier;
            node.typeArguments = typeArguments == null ? undefined : typescript4Cast.createNodeArray(typeArguments);
            node.isTypeOf = isTypeOfOrUndefined;
            node.transformFlags = 1 /* TransformFlags.ContainsTypeScript */;
            return node;
        }
    }
    function updateImportTypeNode(node, argument, assertionsOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined) {
        if ("updateImportTypeNode" in typescript) {
            if (arguments.length < 6) {
                return typescript4Cast.updateImportTypeNode(node, argument, assertionsOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf);
            }
            else {
                return typescript4Cast.updateImportTypeNode(node, argument, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined);
            }
        }
        else {
            const assertion = assertionsOrQualifier && "assertClause" in assertionsOrQualifier /* SyntaxKind.ImportTypeAssertionContainer */ ? assertionsOrQualifier : undefined;
            const qualifier = assertionsOrQualifier && typescript.isEntityName(assertionsOrQualifier)
                ? assertionsOrQualifier
                : qualifierOrTypeArguments && !Array.isArray(qualifierOrTypeArguments)
                    ? qualifierOrTypeArguments
                    : undefined;
            const typeArguments = Array.isArray(qualifierOrTypeArguments) ? qualifierOrTypeArguments : Array.isArray(typeArgumentsOrIsTypeOf) ? typeArgumentsOrIsTypeOf : undefined;
            isTypeOfOrUndefined = typeof typeArgumentsOrIsTypeOf === "boolean" ? typeArgumentsOrIsTypeOf : typeof isTypeOfOrUndefined === "boolean" ? isTypeOfOrUndefined : node.isTypeOf;
            return node.argument !== argument ||
                node.assertions !== assertion ||
                node.qualifier !== qualifier ||
                node.typeArguments !== typeArguments ||
                node.isTypeOf !== isTypeOfOrUndefined
                ? typescript.setTextRange(createImportTypeNode(argument, assertionsOrQualifier, qualifierOrTypeArguments, typeArgumentsOrIsTypeOf, isTypeOfOrUndefined), node)
                : node;
        }
    }
    function createClassExpression(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
        return typescript4Cast.createClassExpression(modifiers, name, typeParameters, heritageClauses, members);
    }
    function updateClassExpression(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
        return typescript4Cast.updateClassExpression(node, modifiers, name, typeParameters, heritageClauses, members);
    }
    function createExportDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrExportClause, exportClauseOrModuleSpecifier, moduleSpecifierOrUndefined) {
        const isLong = typeof modifiersOrIsTypeOnly !== "boolean" && (arguments.length >= 6 || Array.isArray(modifiersOrIsTypeOnly));
        const isShort = !isLong;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
        const isTypeOnly = (isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrExportClause);
        const exportClause = (isShort ? isTypeOnlyOrExportClause : exportClauseOrModuleSpecifier);
        const moduleSpecifier = (isShort ? exportClauseOrModuleSpecifier : moduleSpecifierOrUndefined);
        return typescript4Cast.createExportDeclaration(decorators, modifiers, exportClause, moduleSpecifier, isTypeOnly);
    }
    function updateExportDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrExportClause, exportClauseOrModuleSpecifier, moduleSpecifierOrUndefined) {
        const isLong = typeof modifiersOrIsTypeOnly !== "boolean" && (arguments.length >= 7 || Array.isArray(modifiersOrIsTypeOnly));
        const isShort = !isLong;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
        const isTypeOnly = (isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrExportClause);
        const exportClause = (isShort ? isTypeOnlyOrExportClause : exportClauseOrModuleSpecifier);
        const moduleSpecifier = (isShort ? exportClauseOrModuleSpecifier : moduleSpecifierOrUndefined);
        return typescript4Cast.updateExportDeclaration(node, decorators, modifiers, exportClause, moduleSpecifier, isTypeOnly);
    }
    function createConstructorDeclaration(decoratorsOrModifiers, modifiersOrParameters, parametersOrBody, bodyOrUndefined) {
        const isShort = arguments.length <= 3;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
        const parameters = (isShort ? modifiersOrParameters : parametersOrBody);
        const body = (isShort ? parametersOrBody : bodyOrUndefined);
        return typescript4Cast.createConstructor(decorators, modifiers, parameters, body);
    }
    function updateConstructorDeclaration(node, decoratorsOrModifiers, modifiersOrParameters, parametersOrBody, bodyOrUndefined) {
        const isShort = arguments.length <= 4;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
        const parameters = (isShort ? modifiersOrParameters : parametersOrBody);
        const body = (isShort ? parametersOrBody : bodyOrUndefined);
        return typescript4Cast.updateConstructor(node, decorators, modifiers, parameters, body);
    }
    function createMethodDeclaration(decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrQuestionToken, questionTokenOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
        const isShort = typeof asteriskTokenOrName === "string" || (asteriskTokenOrName != null && asteriskTokenOrName.kind !== 41); /* AsteriskToken */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
        const asteriskToken = (isShort ? modifiersOrAsteriskToken : asteriskTokenOrName);
        const name = (isShort ? asteriskTokenOrName : nameOrQuestionToken);
        const questionToken = (isShort ? nameOrQuestionToken : questionTokenOrTypeParameters);
        const typeParameters = (isShort ? questionTokenOrTypeParameters : typeParametersOrParameters);
        const parameters = (isShort ? typeParametersOrParameters : parametersOrType);
        const type = (isShort ? parametersOrType : typeOrBody);
        const body = (isShort ? typeOrBody : bodyOrUndefined);
        return typescript4Cast.createMethod(decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body);
    }
    function updateMethodDeclaration(node, decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrQuestionToken, questionTokenOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
        const isShort = (asteriskTokenOrName === null || asteriskTokenOrName === void 0 ? void 0 : asteriskTokenOrName.kind) !== 41; /* AsteriskToken */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
        const asteriskToken = (isShort ? modifiersOrAsteriskToken : asteriskTokenOrName);
        const name = (isShort ? asteriskTokenOrName : nameOrQuestionToken);
        const questionToken = (isShort ? nameOrQuestionToken : questionTokenOrTypeParameters);
        const typeParameters = (isShort ? questionTokenOrTypeParameters : typeParametersOrParameters);
        const parameters = (isShort ? typeParametersOrParameters : parametersOrType);
        const type = (isShort ? parametersOrType : typeOrBody);
        const body = (isShort ? typeOrBody : bodyOrUndefined);
        return typescript4Cast.updateMethod(node, decorators, modifiers, asteriskToken, name, questionToken, typeParameters, parameters, type, body);
    }
    function createParameterDeclaration(decoratorsOrModifiers, modifiersOrDotDotDotToken, dotDotDotTokenOrName, nameOrQuestionToken, questionTokenOrType, typeOrInitializer, initializerOrUndefined) {
        const isShort = typeof dotDotDotTokenOrName === "string" || (dotDotDotTokenOrName != null && dotDotDotTokenOrName.kind !== 25); /* DotDotDotToken */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrDotDotDotToken;
        const dotDotDotToken = (isShort ? modifiersOrDotDotDotToken : dotDotDotTokenOrName);
        const name = (isShort ? dotDotDotTokenOrName : nameOrQuestionToken);
        const questionToken = (isShort ? nameOrQuestionToken : questionTokenOrType);
        const type = (isShort ? questionTokenOrType : typeOrInitializer);
        const initializer = (isShort ? typeOrInitializer : initializerOrUndefined);
        return typescript4Cast.createParameter(decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer);
    }
    function updateParameterDeclaration(node, decoratorsOrModifiers, modifiersOrDotDotDotToken, dotDotDotTokenOrName, nameOrQuestionToken, questionTokenOrType, typeOrInitializer, initializerOrUndefined) {
        const isShort = typeof dotDotDotTokenOrName === "string" || (dotDotDotTokenOrName != null && dotDotDotTokenOrName.kind !== 25); /* DotDotDotToken */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrDotDotDotToken;
        const dotDotDotToken = (isShort ? modifiersOrDotDotDotToken : dotDotDotTokenOrName);
        const name = (isShort ? dotDotDotTokenOrName : nameOrQuestionToken);
        const questionToken = (isShort ? nameOrQuestionToken : questionTokenOrType);
        const type = (isShort ? questionTokenOrType : typeOrInitializer);
        const initializer = (isShort ? typeOrInitializer : initializerOrUndefined);
        return typescript4Cast.updateParameter(node, decorators, modifiers, dotDotDotToken, name, questionToken, type, initializer);
    }
    function createPropertyDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrQuestionOrExclamationToken, questionOrExclamationTokenOrType, typeOrInitializer, initializerOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrQuestionOrExclamationToken);
        const questionOrExclamationToken = (isShort ? nameOrQuestionOrExclamationToken : questionOrExclamationTokenOrType);
        const type = (isShort ? questionOrExclamationTokenOrType : typeOrInitializer);
        const initializer = (isShort ? typeOrInitializer : initializerOrUndefined);
        return typescript4Cast.createProperty(decorators, modifiers, name, questionOrExclamationToken, type, initializer);
    }
    function updatePropertyDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrQuestionOrExclamationToken, questionOrExclamationTokenOrType, typeOrInitializer, initializerOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrQuestionOrExclamationToken);
        const questionOrExclamationToken = (isShort ? nameOrQuestionOrExclamationToken : questionOrExclamationTokenOrType);
        const type = (isShort ? questionOrExclamationTokenOrType : typeOrInitializer);
        const initializer = (isShort ? typeOrInitializer : initializerOrUndefined);
        return typescript4Cast.updateProperty(node, decorators, modifiers, name, questionOrExclamationToken, type, initializer);
    }
    function createSetAccessorDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrBody, bodyOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrParameters);
        const parameters = (isShort ? nameOrParameters : parametersOrBody);
        const body = (isShort ? parametersOrBody : bodyOrUndefined);
        return typescript4Cast.createSetAccessor(decorators, modifiers, name, parameters, body);
    }
    function updateSetAccessorDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrBody, bodyOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrParameters);
        const parameters = (isShort ? nameOrParameters : parametersOrBody);
        const body = (isShort ? parametersOrBody : bodyOrUndefined);
        return typescript4Cast.updateSetAccessor(node, decorators, modifiers, name, parameters, body);
    }
    function createGetAccessorDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrParameters);
        const parameters = (isShort ? nameOrParameters : parametersOrType);
        const type = (isShort ? parametersOrType : typeOrBody);
        const body = (isShort ? typeOrBody : bodyOrUndefined);
        return typescript4Cast.createGetAccessor(decorators, modifiers, name, parameters, type, body);
    }
    function updateGetAccessorDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName));
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrParameters);
        const parameters = (isShort ? nameOrParameters : parametersOrType);
        const type = (isShort ? parametersOrType : typeOrBody);
        const body = (isShort ? typeOrBody : bodyOrUndefined);
        return typescript4Cast.updateGetAccessor(node, decorators, modifiers, name, parameters, type, body);
    }
    function createImportEqualsDeclaration(decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
        const isShort = arguments.length <= 4;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
        const isTypeOnly = (isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrName);
        const name = (isShort ? isTypeOnlyOrName : nameOrModuleReference);
        const moduleReference = (isShort ? nameOrModuleReference : moduleReferenceOrUndefined);
        if (typescript4Cast.createImportEqualsDeclaration.length === 4) {
            return typescript.createImportEqualsDeclaration(decorators, modifiers, name, moduleReference);
        }
        else {
            const normalizedName = typeof name === "string" ? typescript4Cast.createIdentifier(name) : name;
            return typescript4Cast.createImportEqualsDeclaration(decorators, modifiers, isTypeOnly, normalizedName, moduleReference);
        }
    }
    function updateImportEqualsDeclaration(node, decoratorsOrModifiers, modifiersOrIsTypeOnly, isTypeOnlyOrName, nameOrModuleReference, moduleReferenceOrUndefined) {
        const isShort = arguments.length <= 5;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsTypeOnly;
        const isTypeOnly = (isShort ? modifiersOrIsTypeOnly : isTypeOnlyOrName);
        const name = (isShort ? isTypeOnlyOrName : nameOrModuleReference);
        const moduleReference = (isShort ? nameOrModuleReference : moduleReferenceOrUndefined);
        const normalizedName = typeof name === "string" ? typescript4Cast.createIdentifier(name) : name;
        if (typescript4Cast.updateImportEqualsDeclaration.length === 5) {
            return typescript.updateImportEqualsDeclaration(node, decorators, modifiers, normalizedName, moduleReference);
        }
        else {
            return typescript4Cast.updateImportEqualsDeclaration(node, decorators, modifiers, isTypeOnly, normalizedName, moduleReference);
        }
    }
    function createIndexSignature(decoratorsOrModifiers, modifiersOrParameters, parametersOrType, typeOrUndefined) {
        const isShort = arguments.length <= 3;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
        const parameters = (isShort ? modifiersOrParameters : parametersOrType);
        const type = (isShort ? parametersOrType : typeOrUndefined);
        return typescript4Cast.createIndexSignature(decorators, modifiers, parameters, type);
    }
    function updateIndexSignature(node, decoratorsOrModifiers, modifiersOrParameters, parametersOrType, typeOrUndefined) {
        const isShort = arguments.length <= 4;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrParameters;
        const parameters = (isShort ? modifiersOrParameters : parametersOrType);
        const type = (isShort ? parametersOrType : typeOrUndefined);
        return typescript4Cast.updateIndexSignature(node, decorators, modifiers, parameters, type);
    }
    function createImportDeclaration(decoratorsOrModifiers, modifiersOrImportClause, importClauseOrModuleSpecifier, moduleSpecifierOrAssertClause, assertClauseOrUndefined) {
        const isShort = modifiersOrImportClause != null && !Array.isArray(modifiersOrImportClause);
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrImportClause;
        const importClause = (isShort ? modifiersOrImportClause : importClauseOrModuleSpecifier);
        const moduleSpecifier = (isShort ? importClauseOrModuleSpecifier : moduleSpecifierOrAssertClause);
        const assertClause = (isShort ? moduleSpecifierOrAssertClause : assertClauseOrUndefined);
        return typescript4Cast.createImportDeclaration(decorators, modifiers, importClause, moduleSpecifier, assertClause);
    }
    function updateImportDeclaration(node, decoratorsOrModifiers, modifiersOrImportClause, importClauseOrModuleSpecifier, moduleSpecifierOrAssertClause, assertClauseOrUndefined) {
        const isShort = importClauseOrModuleSpecifier != null && importClauseOrModuleSpecifier.kind !== 267; /* ImportClause */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrImportClause;
        const importClause = (isShort ? modifiersOrImportClause : importClauseOrModuleSpecifier);
        const moduleSpecifier = (isShort ? importClauseOrModuleSpecifier : moduleSpecifierOrAssertClause);
        const assertClause = (isShort ? moduleSpecifierOrAssertClause : assertClauseOrUndefined);
        return typescript4Cast.updateImportDeclaration(node, decorators, modifiers, importClause, moduleSpecifier, assertClause);
    }
    const createPrivateIdentifier = (_a = typescript4Cast.createPrivateIdentifier) !== null && _a !== void 0 ? _a : (() => function (text) {
        const node = typescript4Cast.createIdentifier(text);
        return node;
    })();
    function createUniquePrivateName(text) {
        if (text != null && !text.startsWith("#")) {
            throw new TypeError("First character of private identifier must be #: " + text);
        }
        const node = createPrivateIdentifier(text !== null && text !== void 0 ? text : "");
        return node;
    }
    function getGeneratedPrivateNameForNode(node) {
        return createPrivateIdentifier("");
    }
    function createTypeAliasDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrType, typeOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrType);
        const type = (isShort ? typeParametersOrType : typeOrUndefined);
        return typescript4Cast.createTypeAliasDeclaration(decorators, modifiers, name, typeParameters, type);
    }
    function updateTypeAliasDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrType, typeOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrType);
        const type = (isShort ? typeParametersOrType : typeOrUndefined);
        return typescript4Cast.updateTypeAliasDeclaration(node, decorators, modifiers, name, typeParameters, type);
    }
    function createFunctionDeclaration(decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
        const isShort = arguments.length <= 7;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
        const asteriskToken = (isShort ? modifiersOrAsteriskToken : asteriskTokenOrName);
        const name = (isShort ? asteriskTokenOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrParameters);
        const parameters = (isShort ? typeParametersOrParameters : parametersOrType);
        const type = (isShort ? parametersOrType : typeOrBody);
        const body = (isShort ? typeOrBody : bodyOrUndefined);
        return typescript4Cast.createFunctionDeclaration(decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body);
    }
    function updateFunctionDeclaration(node, decoratorsOrModifiers, modifiersOrAsteriskToken, asteriskTokenOrName, nameOrTypeParameters, typeParametersOrParameters, parametersOrType, typeOrBody, bodyOrUndefined) {
        const isShort = arguments.length <= 8;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrAsteriskToken;
        const asteriskToken = (isShort ? modifiersOrAsteriskToken : asteriskTokenOrName);
        const name = (isShort ? asteriskTokenOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrParameters);
        const parameters = (isShort ? typeParametersOrParameters : parametersOrType);
        const type = (isShort ? parametersOrType : typeOrBody);
        const body = (isShort ? typeOrBody : bodyOrUndefined);
        return typescript4Cast.updateFunctionDeclaration(node, decorators, modifiers, asteriskToken, name, typeParameters, parameters, type, body);
    }
    function createClassDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
        const isShort = arguments.length <= 5;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
        return typescript4Cast.createClassDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
    }
    function updateClassDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
        const isShort = arguments.length <= 6;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
        return typescript4Cast.updateClassDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members);
    }
    function createInterfaceDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
        return typescript4Cast.createInterfaceDeclaration(decorators, modifiers, name, typeParameters, heritageClauses, members);
    }
    function updateInterfaceDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrTypeParameters, typeParametersOrHeritageClauses, heritageClausesOrMembers, membersOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrTypeParameters);
        const typeParameters = (isShort ? nameOrTypeParameters : typeParametersOrHeritageClauses);
        const heritageClauses = (isShort ? typeParametersOrHeritageClauses : heritageClausesOrMembers);
        const members = (isShort ? heritageClausesOrMembers : membersOrUndefined);
        return typescript4Cast.updateInterfaceDeclaration(node, decorators, modifiers, name, typeParameters, heritageClauses, members);
    }
    function createEnumDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrMembers, membersOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrMembers);
        const members = (isShort ? nameOrMembers : membersOrUndefined);
        return typescript4Cast.createEnumDeclaration(decorators, modifiers, name, members);
    }
    function updateEnumDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrMembers, membersOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrMembers);
        const members = (isShort ? nameOrMembers : membersOrUndefined);
        return typescript4Cast.updateEnumDeclaration(node, decorators, modifiers, name, members);
    }
    function createModuleDeclaration(decoratorsOrModifiers, modifiersOrName, nameOrBody, bodyOrFlags, flagsOrUndefined) {
        const isShort = typeof modifiersOrName === "string" ||
            (modifiersOrName != null &&
                !Array.isArray(modifiersOrName) &&
                ("escapedText" in modifiersOrName /* Identifier */ || "_literalExpressionBrand" in modifiersOrName)); /* StringLiteral */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrBody);
        const body = (isShort ? nameOrBody : bodyOrFlags);
        const flags = (isShort ? bodyOrFlags : flagsOrUndefined);
        return typescript4Cast.createModuleDeclaration(decorators, modifiers, name, body, flags);
    }
    function updateModuleDeclaration(node, decoratorsOrModifiers, modifiersOrName, nameOrBody, bodyOrUndefined) {
        const isShort = typeof modifiersOrName === "string" ||
            (modifiersOrName != null &&
                !Array.isArray(modifiersOrName) &&
                ("escapedText" in modifiersOrName /* Identifier */ || "_literalExpressionBrand" in modifiersOrName)); /* StringLiteral */
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrName;
        const name = (isShort ? modifiersOrName : nameOrBody);
        const body = (isShort ? nameOrBody : bodyOrUndefined);
        return typescript4Cast.updateModuleDeclaration(node, decorators, modifiers, name, body);
    }
    function createExportAssignment(decoratorsOrModifiers, modifiersOrIsExportEquals, isExportEqualsOrExpression, expressionOrUndefined) {
        const isShort = arguments.length <= 3;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrIsExportEquals;
        const isExportEquals = (isShort ? modifiersOrIsExportEquals : isExportEqualsOrExpression);
        const expression = (isShort ? isExportEqualsOrExpression : expressionOrUndefined);
        return typescript4Cast.createExportAssignment(decorators, modifiers, isExportEquals, expression);
    }
    function updateExportAssignment(node, decoratorsOrModifiers, modifiersOrExpression, expressionOrUndefined) {
        const isShort = arguments.length <= 3;
        const decorators = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[0] : decoratorsOrModifiers;
        const modifiers = isShort ? splitDecoratorsAndModifiers(decoratorsOrModifiers)[1] : modifiersOrExpression;
        const expression = (isShort ? modifiersOrExpression : expressionOrUndefined);
        return typescript4Cast.updateExportAssignment(node, decorators, modifiers, expression);
    }
    function createTypeParameterDeclaration(modifiersOrName, nameOrConstraint, constraintOrDefaultType, defaultTypeOrUndefined) {
        const isShort = typeof modifiersOrName === "string" || (modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName); /* Identifier */
        const modifiers = (isShort ? undefined : modifiersOrName);
        const name = (isShort ? modifiersOrName : nameOrConstraint);
        const constraint = (isShort ? nameOrConstraint : constraintOrDefaultType);
        const defaultType = (isShort ? constraintOrDefaultType : defaultTypeOrUndefined);
        const typeParameterDeclaration = typescript4Cast.createTypeParameterDeclaration(name, constraint, defaultType);
        if (modifiers != null) {
            typeParameterDeclaration.modifiers = typescript4Cast.createNodeArray(modifiers);
        }
        return typeParameterDeclaration;
    }
    function updateTypeParameterDeclaration(node, modifiersOrName, nameOrConstraint, constraintOrDefaultType, defaultTypeOrUndefined) {
        const isShort = modifiersOrName != null && !Array.isArray(modifiersOrName) && "escapedText" in modifiersOrName; /* Identifier */
        const modifiers = (isShort ? undefined : modifiersOrName);
        const name = (isShort ? modifiersOrName : nameOrConstraint);
        const constraint = (isShort ? nameOrConstraint : constraintOrDefaultType);
        const defaultType = (isShort ? constraintOrDefaultType : defaultTypeOrUndefined);
        const typeParameterDeclaration = typescript4Cast.updateTypeParameterDeclaration(node, name, constraint, defaultType);
        if (modifiers != null) {
            typeParameterDeclaration.modifiers = typescript4Cast.createNodeArray(modifiers);
        }
        return typeParameterDeclaration;
    }
    const { updateSourceFileNode, ...common } = typescript;
    return {
        ["__compatUpgraded"]: true,
        ...common,
        createToken: createToken,
        createConstructorTypeNode,
        updateConstructorTypeNode,
        createImportTypeNode,
        updateImportTypeNode,
        createJSDocComment,
        createJSDocParameterTag,
        createJSDocPrivateTag,
        createJSDocAugmentsTag,
        createJSDocAuthorTag,
        createJSDocCallbackTag,
        createJSDocClassTag,
        createJSDocEnumTag,
        createJSDocImplementsTag,
        createJSDocPropertyTag,
        createJSDocProtectedTag,
        createJSDocPublicTag,
        createJSDocReadonlyTag,
        createJSDocReturnTag,
        createJSDocSignature,
        createJSDocTemplateTag,
        createJSDocThisTag,
        createJSDocTypeExpression,
        createJSDocTypeLiteral,
        createJSDocTypeTag,
        createJSDocTypedefTag,
        createJSDocAllType,
        createJSDocDeprecatedTag,
        createJSDocFunctionType,
        createJSDocLink,
        createJSDocNameReference,
        createJSDocNamepathType,
        createJSDocNonNullableType,
        createJSDocNullableType,
        createJSDocOptionalType,
        createJSDocOverrideTag,
        createJSDocSeeTag,
        createJSDocText,
        createJSDocUnknownTag,
        createJSDocUnknownType,
        createJSDocVariadicType,
        createJSDocMemberName,
        createJSDocLinkCode,
        createJSDocLinkPlain,
        createJSDocOverloadTag,
        createJSDocThrowsTag,
        createJSDocSatisfiesTag,
        createTemplateLiteralType,
        createTemplateLiteralTypeSpan,
        createClassStaticBlockDeclaration,
        createAssertClause,
        createAssertEntry,
        createImportTypeAssertionContainer,
        createJsxNamespacedName,
        createIndexSignature,
        updateIndexSignature,
        createSatisfiesExpression,
        updateSatisfiesExpression,
        createImportDeclaration,
        updateImportDeclaration,
        createUniquePrivateName,
        createPrivateIdentifier,
        getGeneratedPrivateNameForNode,
        createTypeAliasDeclaration,
        updateTypeAliasDeclaration,
        createFunctionDeclaration,
        updateFunctionDeclaration,
        createClassDeclaration,
        updateClassDeclaration,
        createInterfaceDeclaration,
        updateInterfaceDeclaration,
        createEnumDeclaration,
        updateEnumDeclaration,
        createModuleDeclaration,
        updateModuleDeclaration,
        createExportAssignment,
        updateExportAssignment,
        createTypeParameterDeclaration,
        updateTypeParameterDeclaration,
        createComma(left, right) {
            return typescript4Cast.createComma(left, right);
        },
        createAssignment(left, right) {
            return typescript4Cast.createAssignment(left, right);
        },
        createLessThan(left, right) {
            return typescript4Cast.createLessThan(left, right);
        },
        createSourceFile(statements, endOfFileToken, flags) {
            const sourceFile = typescript.createSourceFile("", "", 0, undefined, 0);
            sourceFile.endOfFileToken = endOfFileToken;
            sourceFile.flags |= flags;
            sourceFile.statements = typescript4Cast.createNodeArray(statements);
            return sourceFile;
        },
        createClassExpression,
        createExpressionWithTypeArguments(expression, typeArguments) {
            return typescript4Cast.createExpressionWithTypeArguments(typeArguments, expression);
        },
        updateExpressionWithTypeArguments(node, expression, typeArguments) {
            return typescript4Cast.updateExpressionWithTypeArguments(node, typeArguments, expression);
        },
        updateImportClause(node, isTypeOnly, name, namedBindings) {
            return typescript4Cast.updateImportClause(node, name, namedBindings, isTypeOnly);
        },
        updateExportDeclaration,
        createTypePredicateNode(assertsModifier, parameterName, type) {
            return typescript4Cast.createTypePredicateNode(parameterName, type);
        },
        updateTypePredicateNode(node, assertsModifier, parameterName, type) {
            return typescript4Cast.updateTypePredicateNode(node, parameterName, type);
        },
        createMethodSignature(modifiers, name, questionToken, typeParameters, parameters, type) {
            const methodSignature = typescript4Cast.createMethodSignature(typeParameters, parameters, type, name, questionToken);
            // Also set the modifiers
            // Workaround for: https://github.com/microsoft/TypeScript/issues/35959
            if (modifiers != null) {
                methodSignature.modifiers = typescript4Cast.createNodeArray(modifiers);
            }
            return methodSignature;
        },
        updateMethodSignature(node, modifiers, name, questionToken, typeParameters, parameters, type) {
            const methodSignature = typescript4Cast.updateMethodSignature(node, typeParameters, parameters, type, name, questionToken);
            // Also set the modifiers
            // Workaround for: https://github.com/microsoft/TypeScript/issues/35959
            if (modifiers !== methodSignature.modifiers) {
                methodSignature.modifiers = modifiers == null ? modifiers : typescript4Cast.createNodeArray(modifiers);
            }
            return methodSignature;
        },
        updatePropertySignature(node, modifiers, name, questionToken, type) {
            return typescript4Cast.updatePropertySignature(node, modifiers, name, questionToken, type, undefined);
        },
        createAwaitExpression(expression) {
            return typescript4Cast.createAwait(expression);
        },
        createBinaryExpression(left, operator, right) {
            return typescript4Cast.createBinary(left, operator, right);
        },
        createBitwiseAnd(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.AmpersandToken, right);
        },
        createBitwiseNot(operand) {
            return typescript4Cast.createPrefix(typescript.SyntaxKind.TildeToken, operand);
        },
        createBitwiseOr(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.BarToken, right);
        },
        createBitwiseXor(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.CaretToken, right);
        },
        createBreakStatement(label) {
            return typescript4Cast.createBreak(label);
        },
        createCommaListExpression(elements) {
            return typescript4Cast.createCommaList(elements);
        },
        createConditionalExpression(condition, questionToken, whenTrue, colonToken, whenFalse) {
            if (questionToken == null || colonToken == null) {
                return typescript4Cast.createConditional(condition, whenTrue, whenFalse);
            }
            return typescript4Cast.createConditional(condition, questionToken, whenTrue, colonToken, whenFalse);
        },
        createConstructorDeclaration,
        createContinueStatement(label) {
            return typescript4Cast.createContinue(label);
        },
        createDeleteExpression(expression) {
            return typescript4Cast.createDelete(expression);
        },
        createDivide(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.SlashToken, right);
        },
        createDoStatement(statement, expression) {
            return typescript4Cast.createDo(statement, expression);
        },
        createElementAccessExpression(expression, index) {
            return typescript4Cast.createElementAccess(expression, index);
        },
        createEquality(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.EqualsEqualsToken, right);
        },
        createExponent(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.AsteriskAsteriskToken, right);
        },
        createForInStatement(initializer, expression, statement) {
            return typescript4Cast.createForIn(initializer, expression, statement);
        },
        createForOfStatement(awaitModifier, initializer, expression, statement) {
            return typescript4Cast.createForOf(awaitModifier, initializer, expression, statement);
        },
        createForStatement(initializer, condition, incrementor, statement) {
            return typescript4Cast.createFor(initializer, condition, incrementor, statement);
        },
        createGreaterThan(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.GreaterThanToken, right);
        },
        createGreaterThanEquals(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.GreaterThanEqualsToken, right);
        },
        createIfStatement(expression, thenStatement, elseStatement) {
            return typescript4Cast.createIf(expression, thenStatement, elseStatement);
        },
        createInequality(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.ExclamationEqualsToken, right);
        },
        createLabeledStatement(label, statement) {
            return typescript4Cast.createLabel(label, statement);
            createParameterDeclaration;
        },
        createLeftShift(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.LessThanLessThanToken, right);
        },
        createLessThanEquals(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.LessThanEqualsToken, right);
        },
        createMethodDeclaration,
        createModulo(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.PercentToken, right);
        },
        createMultiply(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.AsteriskToken, right);
        },
        createNamedTupleMember,
        createNewExpression(expression, typeArguments, argumentsArray) {
            return typescript4Cast.createNew(expression, typeArguments, argumentsArray);
        },
        createParameterDeclaration,
        createParenthesizedExpression(expression) {
            return typescript4Cast.createParen(expression);
        },
        createPostfixDecrement(operand) {
            return typescript4Cast.createPostfix(operand, typescript.SyntaxKind.MinusMinusToken);
        },
        createPostfixUnaryExpression(operand, operator) {
            return typescript4Cast.createPostfix(operand, operator);
        },
        createPrefixDecrement(operand) {
            return typescript4Cast.createPrefix(typescript.SyntaxKind.MinusMinusToken, operand);
        },
        createPrefixIncrement(operand) {
            return typescript4Cast.createPrefix(typescript.SyntaxKind.PlusPlusToken, operand);
        },
        createPrefixMinus(operand) {
            return typescript4Cast.createPrefix(typescript.SyntaxKind.MinusToken, operand);
        },
        createPrefixPlus(operand) {
            return typescript4Cast.createPrefix(typescript.SyntaxKind.PlusToken, operand);
        },
        createPrefixUnaryExpression(operator, operand) {
            return typescript4Cast.createPrefix(operator, operand);
        },
        createPropertyDeclaration,
        createRightShift(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.GreaterThanGreaterThanToken, right);
        },
        createSetAccessorDeclaration,
        createSpreadElement(expression) {
            return typescript4Cast.createSpread(expression);
        },
        createSwitchStatement(expression, caseBlock) {
            return typescript4Cast.createSwitch(expression, caseBlock);
        },
        createTaggedTemplateExpression(tag, typeArguments, template) {
            return typescript4Cast.createTaggedTemplate(tag, typeArguments, template);
        },
        createThrowStatement(expression) {
            return typescript4Cast.createThrow(expression);
        },
        createTryStatement(tryBlock, catchClause, finallyBlock) {
            return typescript4Cast.createTry(tryBlock, catchClause, finallyBlock);
        },
        createTypeOfExpression(expression) {
            return typescript4Cast.createTypeOf(expression);
        },
        createUnsignedRightShift(left, right) {
            return typescript4Cast.createBinary(left, typescript.SyntaxKind.GreaterThanGreaterThanGreaterThanToken, right);
        },
        createVoidExpression(expression) {
            return typescript4Cast.createVoid(expression);
        },
        createWhileStatement(expression, statement) {
            return typescript4Cast.createWhile(expression, statement);
        },
        createWithStatement(expression, statement) {
            return typescript4Cast.createWith(expression, statement);
        },
        createYieldExpression(asteriskToken, expression) {
            return typescript4Cast.createYield(asteriskToken, expression);
        },
        restoreOuterExpressions(outerExpression, innerExpression, kinds) {
            return innerExpression;
        },
        updateAwaitExpression(node, expression) {
            return typescript4Cast.updateAwait(node, expression);
        },
        updateBinaryExpression(node, left, operator, right) {
            return typescript4Cast.updateBinary(node, left, right, operator);
        },
        updateBreakStatement(node, label) {
            return typescript4Cast.updateBreak(node, label);
        },
        updateCommaListExpression(node, elements) {
            return typescript4Cast.updateCommaList(node, elements);
        },
        updateConditionalExpression(node, condition, questionToken, whenTrue, colonToken, whenFalse) {
            return typescript4Cast.updateConditional(node, condition, questionToken, whenTrue, colonToken, whenFalse);
        },
        updateContinueStatement(node, label) {
            return typescript4Cast.updateContinue(node, label);
        },
        updateDeleteExpression(node, expression) {
            return typescript4Cast.updateDelete(node, expression);
        },
        updateDoStatement(node, statement, expression) {
            return typescript4Cast.updateDo(node, statement, expression);
        },
        updateElementAccessExpression(node, expression, argumentExpression) {
            return typescript4Cast.updateElementAccess(node, expression, argumentExpression);
        },
        updateForInStatement(node, initializer, expression, statement) {
            return typescript4Cast.updateForIn(node, initializer, expression, statement);
        },
        updateForOfStatement(node, awaitModifier, initializer, expression, statement) {
            return typescript4Cast.updateForOf(node, awaitModifier, initializer, expression, statement);
        },
        updateForStatement(node, initializer, condition, incrementor, statement) {
            return typescript4Cast.updateFor(node, initializer, condition, incrementor, statement);
        },
        updateIfStatement(node, expression, thenStatement, elseStatement) {
            return typescript4Cast.updateIf(node, expression, thenStatement, elseStatement);
        },
        updateJSDocAugmentsTag(node, tagName, className, comment) {
            return tagName === node.tagName && className === node.class && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocAugmentsTag(tagName, className, comment), node);
        },
        updateJSDocAuthorTag(node, tagName, comment) {
            return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocAuthorTag(tagName, comment), node);
        },
        updateJSDocCallbackTag(node, tagName, typeExpression, fullName, comment) {
            return tagName === node.tagName && typeExpression === node.typeExpression && fullName === node.fullName && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocCallbackTag(tagName, typeExpression, fullName, comment), node);
        },
        updateJSDocClassTag(node, tagName, comment) {
            return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocClassTag(tagName, comment), node);
        },
        updateJSDocComment(node, comment, tags) {
            return comment === node.comment && tags === node.tags ? node : typescript.setTextRange(createJSDocComment(comment, tags), node);
        },
        updateJSDocDeprecatedTag(node, tagName, comment) {
            return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocDeprecatedTag(tagName, comment), node);
        },
        updateJSDocEnumTag(node, tagName, typeExpression, comment) {
            return tagName === node.tagName && typeExpression === node.typeExpression ? node : typescript.setTextRange(createJSDocEnumTag(tagName, typeExpression, comment), node);
        },
        updateJSDocFunctionType(node, parameters, type) {
            return parameters === node.parameters && type === node.type ? node : typescript.setTextRange(createJSDocFunctionType(parameters, type), node);
        },
        updateJSDocImplementsTag(node, tagName, className, comment) {
            return tagName === node.tagName && className === node.class && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocImplementsTag(tagName, className, comment), node);
        },
        updateJSDocLink(node, name, text) {
            return name === node.name && text === node.text ? node : typescript.setTextRange(createJSDocLink(name, text), node);
        },
        updateJSDocNameReference(node, name) {
            return name === node.name ? node : typescript.setTextRange(createJSDocNameReference(name), node);
        },
        updateJSDocNamepathType(node, type) {
            return type === node.type ? node : typescript.setTextRange(createJSDocNamepathType(type), node);
        },
        updateJSDocNonNullableType(node, type) {
            return type === node.type ? node : typescript.setTextRange(createJSDocNonNullableType(type), node);
        },
        updateJSDocNullableType(node, type) {
            return type === node.type ? node : typescript.setTextRange(createJSDocNullableType(type), node);
        },
        updateJSDocOptionalType(node, type) {
            return type === node.type ? node : typescript.setTextRange(createJSDocOptionalType(type), node);
        },
        updateJSDocOverrideTag(node, tagName, comment) {
            return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocOverrideTag(tagName, comment), node);
        },
        updateJSDocParameterTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            return tagName === node.tagName &&
                name === node.name &&
                isBracketed === node.isBracketed &&
                typeExpression === node.typeExpression &&
                isNameFirst === node.isNameFirst &&
                comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocParameterTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node);
        },
        updateJSDocPrivateTag(node, tagName, comment) {
            return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocPrivateTag(tagName, comment), node);
        },
        updateJSDocPropertyTag(node, tagName, name, isBracketed, typeExpression, isNameFirst, comment) {
            return tagName === node.tagName &&
                name === node.name &&
                isBracketed === node.isBracketed &&
                typeExpression === node.typeExpression &&
                isNameFirst === node.isNameFirst &&
                comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocPropertyTag(tagName, name, isBracketed, typeExpression, isNameFirst, comment), node);
        },
        updateJSDocProtectedTag(node, tagName, comment) {
            return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocProtectedTag(tagName, comment), node);
        },
        updateJSDocPublicTag(node, tagName, comment) {
            return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocPublicTag(tagName, comment), node);
        },
        updateJSDocReadonlyTag(node, tagName, comment) {
            return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocReadonlyTag(tagName, comment), node);
        },
        updateJSDocReturnTag(node, tagName, typeExpression, comment) {
            return tagName === node.tagName && comment === node.comment && typeExpression === node.typeExpression
                ? node
                : typescript.setTextRange(createJSDocReturnTag(tagName, typeExpression, comment), node);
        },
        updateJSDocSeeTag(node, tagName, nameExpression, comment) {
            return tagName === node.tagName && nameExpression === node.name && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocSeeTag(tagName, nameExpression, comment), node);
        },
        updateJSDocSignature(node, typeParameters, parameters, type) {
            return typeParameters === node.typeParameters && parameters === node.parameters && type === node.type
                ? node
                : typescript.setTextRange(createJSDocSignature(typeParameters, parameters, type), node);
        },
        updateJSDocTemplateTag(node, tagName, constraint, typeParameters, comment) {
            return tagName === node.tagName && constraint === node.constraint && typeParameters === node.typeParameters && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocTemplateTag(tagName, constraint, typeParameters, comment), node);
        },
        updateJSDocText(node, text) {
            return text === node.text ? node : typescript.setTextRange(createJSDocText(text), node);
        },
        updateJSDocThisTag(node, tagName, typeExpression, comment) {
            return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocThisTag(tagName, typeExpression, comment), node);
        },
        updateJSDocTypeExpression(node, type) {
            return type === node.type ? node : typescript.setTextRange(createJSDocTypeExpression(type), node);
        },
        updateJSDocTypeLiteral(node, jsDocPropertyTags, isArrayType) {
            return jsDocPropertyTags === node.jsDocPropertyTags && isArrayType === node.isArrayType
                ? node
                : typescript.setTextRange(createJSDocTypeLiteral(jsDocPropertyTags, isArrayType), node);
        },
        updateJSDocTypeTag(node, tagName, typeExpression, comment) {
            return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocTypeTag(tagName, typeExpression, comment), node);
        },
        updateJSDocTypedefTag(node, tagName, typeExpression, fullName, comment) {
            return tagName === node.tagName && typeExpression === node.typeExpression && fullName === node.fullName && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocTypedefTag(tagName, typeExpression, fullName, comment), node);
        },
        updateJSDocUnknownTag(node, tagName, comment) {
            return tagName === node.tagName && comment === node.comment ? node : typescript.setTextRange(createJSDocUnknownTag(tagName, comment), node);
        },
        updateJSDocVariadicType(node, type) {
            return type === node.type ? node : typescript.setTextRange(createJSDocVariadicType(type), node);
        },
        updateJSDocMemberName(node, left, right) {
            return left === node.left && right === node.right ? node : typescript.setTextRange(createJSDocMemberName(left, right), node);
        },
        updateJSDocLinkCode(node, name, text) {
            return name === node.name && text === node.text ? node : typescript.setTextRange(createJSDocLinkCode(name, text), node);
        },
        updateJSDocLinkPlain(node, name, text) {
            return name === node.name && text === node.text ? node : typescript.setTextRange(createJSDocLinkPlain(name, text), node);
        },
        updateJSDocOverloadTag(node, tagName, typeExpression, comment) {
            return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocOverloadTag(tagName, typeExpression, comment), node);
        },
        updateJSDocThrowsTag(node, tagName, typeExpression, comment) {
            return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocThrowsTag(tagName !== null && tagName !== void 0 ? tagName : node.tagName, typeExpression, comment), node);
        },
        updateJSDocSatisfiesTag(node, tagName, typeExpression, comment) {
            return tagName === node.tagName && typeExpression === node.typeExpression && comment === node.comment
                ? node
                : typescript.setTextRange(createJSDocSatisfiesTag(tagName, typeExpression, comment), node);
        },
        updateLabeledStatement(node, label, statement) {
            return typescript4Cast.updateLabel(node, label, statement);
        },
        updateMethodDeclaration,
        updateNamedTupleMember(node, dotDotDotToken, name, questionToken, type) {
            return dotDotDotToken === node.dotDotDotToken && name === node.name && questionToken === node.questionToken && type === node.type
                ? node
                : typescript.setTextRange(createNamedTupleMember(dotDotDotToken, name, questionToken, type), node);
        },
        updateNewExpression(node, expression, typeArguments, argumentsArray) {
            return typescript4Cast.updateNew(node, expression, typeArguments, argumentsArray);
        },
        updateObjectLiteralExpression(node, properties) {
            return typescript4Cast.updateObjectLiteral(node, properties);
        },
        updateParameterDeclaration,
        updateParenthesizedExpression(node, expression) {
            return typescript4Cast.updateParen(node, expression);
        },
        updatePostfixUnaryExpression(node, operand) {
            return typescript4Cast.updatePostfix(node, operand);
        },
        updatePrefixUnaryExpression(node, operand) {
            return typescript4Cast.updatePrefix(node, operand);
        },
        updatePropertyAccessExpression(node, expression, name) {
            return typescript4Cast.updatePropertyAccess(node, expression, name);
        },
        updatePropertyDeclaration,
        updateReturnStatement(node, expression) {
            return typescript4Cast.updateReturn(node, expression);
        },
        updateSetAccessorDeclaration,
        updateSpreadElement(node, expression) {
            return typescript4Cast.updateSpread(node, expression);
        },
        updateSwitchStatement(node, expression, caseBlock) {
            return typescript4Cast.updateSwitch(node, expression, caseBlock);
        },
        updateTaggedTemplateExpression(node, tag, typeArguments, template) {
            return typescript4Cast.updateTaggedTemplate(node, tag, typeArguments, template);
        },
        updateTemplateLiteralType(node, head, templateSpans) {
            return head === node.head && templateSpans === node.templateSpans ? node : typescript.setTextRange(createTemplateLiteralType(head, templateSpans), node);
        },
        updateTemplateLiteralTypeSpan(node, type, literal) {
            return type === node.type && literal === node.literal ? node : typescript.setTextRange(createTemplateLiteralTypeSpan(type, literal), node);
        },
        updateClassStaticBlockDeclaration,
        updateAssertClause(node, elements, multiLine) {
            return node.elements !== elements || node.multiLine !== multiLine ? typescript.setTextRange(createAssertClause(elements, multiLine), node) : node;
        },
        updateAssertEntry(node, name, value) {
            return node.name !== name || node.value !== value ? typescript.setTextRange(createAssertEntry(name, value), node) : node;
        },
        updateImportTypeAssertionContainer(node, clause, multiLine) {
            return node.assertClause !== clause || node.multiLine !== multiLine ? typescript.setTextRange(createImportTypeAssertionContainer(clause, multiLine), node) : node;
        },
        updateJsxNamespacedName(node, namespace, name) {
            return node.namespace !== namespace || node.name !== name ? typescript.setTextRange(createJsxNamespacedName(namespace, name), node) : node;
        },
        updateThrowStatement(node, expression) {
            return typescript4Cast.updateThrow(node, expression);
        },
        updateTryStatement(node, tryBlock, catchClause, finallyBlock) {
            return typescript4Cast.updateTry(node, tryBlock, catchClause, finallyBlock);
        },
        updateTypeOfExpression(node, expression) {
            return typescript4Cast.updateTypeOf(node, expression);
        },
        updateVoidExpression(node, expression) {
            return typescript4Cast.updateVoid(node, expression);
        },
        updateWhileStatement(node, expression, statement) {
            return typescript4Cast.updateWhile(node, expression, statement);
        },
        updateWithStatement(node, expression, statement) {
            return typescript4Cast.updateWith(node, expression, statement);
        },
        updateYieldExpression(node, asteriskToken, expression) {
            return typescript4Cast.updateYield(node, asteriskToken, expression);
        },
        createImportClause(isTypeOnly, name, namedBindings) {
            return typescript4Cast.createImportClause(name, namedBindings, isTypeOnly);
        },
        createCallExpression(expression, typeArguments, argumentsArray) {
            return typescript4Cast.createCall(expression, typeArguments, argumentsArray);
        },
        updateCallExpression(node, expression, typeArguments, argumentsArray) {
            return typescript4Cast.updateCall(node, expression, typeArguments, argumentsArray);
        },
        createArrayLiteralExpression(elements, multiLine) {
            return typescript4Cast.createArrayLiteral(elements, multiLine);
        },
        updateArrayLiteralExpression(node, elements) {
            return typescript4Cast.updateArrayLiteral(node, elements);
        },
        updateSourceFile(node, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences) {
            return typescript4Cast.updateSourceFileNode(node, statements, isDeclarationFile, referencedFiles, typeReferences, hasNoDefaultLib, libReferences);
        },
        updateClassExpression,
        createPropertyAccessExpression(expression, name) {
            return typescript4Cast.createPropertyAccess(expression, name);
        },
        createGetAccessorDeclaration,
        updateGetAccessorDeclaration,
        createReturnStatement(expression) {
            return typescript4Cast.createReturn(expression);
        },
        createObjectLiteralExpression(properties, multiLine) {
            return typescript4Cast.createObjectLiteral(properties, multiLine);
        },
        createVariableDeclaration(name, exclamationToken, type, initializer) {
            if (typescript4Cast.createVariableDeclaration.length === 4) {
                return typescript4Cast.createVariableDeclaration(name, exclamationToken, type, initializer);
            }
            return typescript4Cast.createVariableDeclaration(name, type, initializer);
        },
        updateVariableDeclaration(node, name, exclamationToken, type, initializer) {
            if (typescript4Cast.updateVariableDeclaration.length === 4) {
                return typescript4Cast.updateVariableDeclaration(node, name, type, initializer);
            }
            return typescript4Cast.updateVariableDeclaration(node, name, exclamationToken, type, initializer);
        },
        createPropertyAccessChain(expression, questionDotToken, name) {
            if ("createPropertyAccessChain" in typescript) {
                return typescript4Cast.createPropertyAccessChain(expression, questionDotToken, name);
            }
            const node = typescript4Cast.createPropertyAccess(expression, name);
            node.questionDotToken = questionDotToken;
            return node;
        },
        updatePropertyAccessChain(node, expression, questionDotToken, name) {
            if ("updatePropertyAccessChain" in typescript) {
                return typescript4Cast.updatePropertyAccessChain(node, expression, questionDotToken, name);
            }
            const newNode = typescript4Cast.updatePropertyAccess(node, expression, name);
            newNode.questionDotToken = questionDotToken;
            return newNode;
        },
        createImportEqualsDeclaration,
        updateImportEqualsDeclaration,
        createMappedTypeNode(readonlyToken, typeParameter, nameType, questionToken, type, members) {
            return typescript.createMappedTypeNode(readonlyToken, typeParameter, questionToken, type);
        },
        updateMappedTypeNode(node, readonlyToken, typeParameter, nameType, questionToken, type, members) {
            return typescript.updateMappedTypeNode(node, readonlyToken, typeParameter, questionToken, type);
        },
        createImportSpecifier(isTypeOnly, propertyName, name) {
            return typescript.createImportSpecifier(propertyName, name);
        },
        updateImportSpecifier(node, isTypeOnly, propertyName, name) {
            return typescript.updateImportSpecifier(node, propertyName, name);
        },
        createExportSpecifier(isTypeOnly, propertyName, name) {
            return typescript.createExportSpecifier(propertyName, name);
        },
        updateExportSpecifier(node, isTypeOnly, propertyName, name) {
            return typescript.updateExportSpecifier(node, propertyName, name);
        },
        createExportDeclaration,
        updateConstructorDeclaration,
        /**
         * Some TypeScript versions require that the value is a string argument
         */
        createNumericLiteral(value, numericLiteralFlags) {
            return typescript4Cast.createNumericLiteral(String(value), numericLiteralFlags);
        }
    };
}
//# sourceMappingURL=index.js.map